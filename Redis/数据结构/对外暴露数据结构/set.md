## <h3 id="redis_data_structure_4">集合对象(set)</h3>
> - set是一个存放不重复值的无序集合，可做全局去重的功能，提供了判断某个元素是否在set集合内的功能，这个也是list所不能提供的。基于set可以实现交集、并集、差集的操作，计算共同喜好，全部的喜好，自己独有的喜好等功能。
> - 集合对象的编码可以是intset和hashtable之一。
### 1 底层实现
#### 1.1 intset编码
intset编码的集合对象底层实现是整数集合，所有元素都保存在整数集合中。<br/>
![image](https://user-images.githubusercontent.com/87458342/132521935-98713a61-bc4e-47c5-a79d-168aaa2639f4.png)
 
#### 1.2 hashtable编码
hashtable编码的集合对象底层实现是字典，字典的每个键都是一个字符串对象，保存一个集合元素，不同的是字典的值都是NULL；可以参考java中的hashset结构。<br/>
![image](https://user-images.githubusercontent.com/87458342/132522046-75ce3940-7082-4a56-966b-bf223f2b5bf4.png)
 
#### 1.3 集合对象编码转换：
集合对象使用intset编码需要满足两个条件：
- 一是所有元素都是整数值；
- 二是元素个数小于等于512个
不满足任意一条都将使用hashtable编码。以上第二个条件可以在Redis配置文件中修改et-max-intset-entries选项。
 
### 2 交、并、差运算
Redis set的并、交、差算法的实现代码，在t_set.c中。其中计算交集调用的是sinterGenericCommand，计算并集和差集调用的是sunionDiffGenericCommand。它们都能同时对多个（可以多于2个）集合进行运算。当对多个集合进行差集运算时，它表达的含义是：用第一个集合与第二个集合做差集，所得结果再与第三个集合做差集，依次向后类推。
#### 2.1 交集
计算交集的过程大概可以分为三部分：
- 检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，则不用继续计算了，最终的交集就是空集。
- 对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。
- 对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。
**需要注意的是:**
上述第3步在集合中进行查找，对于intset和dict的存储来说时间复杂度分别是O(log n)和O(1)。但由于只有小集合才使用intset，所以可以粗略地认为intset的查找也是常数时间复杂度的。因此，如Redis官方文档上所说（http://redis.io/commands/sinter），sinter命令的时间复杂度为：O(N*M)，其中N是第一个集合的元素个数，而M是参与运算的集合的个数。

#### 2.2 并集
计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。向集合中添加元素会自动去重。

由于要遍历所有集合的每个元素，所以Redis官方文档给出的sunion命令的时间复杂度为O(N)，其中N是参与运算的集合个数。

**注意**，这里同前面讨论交集计算一样，将元素插入到结果集合的过程，忽略intset的情况，认为时间复杂度为O(1)。
#### 2.3 差集
- 计算差集有两种可能的算法，它们的时间复杂度有所区别。
- 在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。还有两点需要注意：
  - 在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。
  - 如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。

对于sdiff的时间复杂度，Redis官方文档（http://redis.io/commands/sdiff）只给出了第二种算法的结果，是不准确的。

**第一种算法：**
- 对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。

> 这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。

**第二种算法：**
- 将第一个集合的所有元素都加入到一个中间集合中。
- 遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。
- 最后中间集合剩下的元素就构成了差集。
> 这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。
#### 2.4 示例
**1）set 常用命令**
- sadd用于分别向集合s1和s2中添加元素。添加的元素既有数字，也有非数字（”a”和”b”）。
- sismember用于判断指定的元素是否在集合内存在。
- sinter, sunion和sdiff分别用于计算集合的交集、并集和差集。
![set 常见操作](<../../images/set 常用命令.png>)

**2）底层实现**
**a. set 实现**
set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。例如，具体到上述命令的执行过程中，集合s1的底层数据结构会发生如下变化：
  - 在开始执行完sadd s1 13 5之后，由于添加的都是比较小的整数，所以s1底层是一个intset，其数据编码encoding = 2。
  - 在执行完sadd s1 32768 10 100000之后，s1底层仍然是一个intset，但其数据编码encoding从2升级到了4。
  - 在执行完sadd s1 a b之后，由于添加的元素不再是数字，s1底层的实现会转成一个dict。

另外两种实现转换情况：
- 添加了一个数字，但它无法用64bit的有符号数来表达。intset能够表达的最大的整数范围为-2^64~2^64-1，因此，如果添加的数字超出了这个范围，这也会导致intset转成dict。
- 添加的集合元素个数超过了set-max-intset-entries配置的值的时候，也会导致intset转成dict（具体的触发条件参见t_set.c中的setTypeAdd相关代码）。
> redis.conf 中配置 set-max-intset-entries
> set-max-intset-entries 512

**b.dict 实现：**
- dict是一个用于维护key和value映射关系的数据结构，那么当set底层用dict表示的时候，它的key和value分别是什么呢？实际上，key就是要添加的集合元素，而value是NULL。

**c.两种实现对比**
- 对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。

- 实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。
### 3 应用场景：
1. 共同好友
2. 利用唯一性，统计访问网站的所有独立ip
