## 简介
- 经常使用先更新数据库，再删除缓存的策略

## 更新缓存
### 先更新数据库，再更新缓存
- A 请求先将数据库的数据更新为 1，
- 然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，
- 然后 A 请求更新缓存为 1。
![先更新数据库-再更新缓存](images/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98.webp)

### 先更新缓存，再更新数据库
- A 请求先将缓存的数据更新为 1，
- 然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，
- 然后 A 请求将数据库的数据更新为 1。
- 此时，数据库中的数据是 1，而缓存中的数据却是 2，出现了缓存和数据库中的数据不一致的现象。
![先更新缓存，再更新数据库](images/%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93.webp)

## 删除缓存
### Cache Aside
- 不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。
- 这个策略是有名字的，Cache Aside 策略，中文是叫旁路缓存策略
- 该策略又可以细分为「读策略」和「写策略」。
![读策略-写策略](images/%E8%AF%BB%E7%AD%96%E7%95%A5-%E5%86%99%E7%AD%96%E7%95%A5.webp)
1) 写策略
- 更新数据库中的数据；
- 删除缓存中的数据。
2) 读策略
- 如果读取的数据命中了缓存，则直接返回数据； 
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

### 先删除缓存，再更新数据库
- 假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。
- 这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，
- 然后请求 A 继续更改数据库，将用户的年龄更新为 21。
![先删除缓存，再更新数据库](images/%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98-%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93.webp)
- 最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。 
- 可以看到，先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题
1) 数据不一致问题怎样解决？
针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「延迟双删」。
```shell
#删除缓存 
redis.delKey(X) 

#更新数据库 
db.update(X) 

#睡眠 
Thread.sleep(N) 

#再删除缓存 
redis.delKey(X)
```
- 加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，
- 然后请求 A 睡眠完，再删除缓存。 
- 所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。 
- 但是具体睡眠多久其实是个玄学，很难评估出来，所以这个方案也只是尽可能保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。 
- 因此，还是比较建议用「先更新数据库，再删除缓存」的方案。 #

### 先更新数据库，再删除缓存
- 假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，
- 在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。
- 这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。
![先更新数据库，再删除缓存](images/%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98.webp)
- 最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。
- 从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，但是在实际中，这个问题出现的概率并不高。
- 因为缓存的写入通常要远远快于数据库的写入，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。
- 而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。
- **所以，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。**
#### 删除缓存失败措施
- 给缓存数据加上了「过期时间」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。

#### 怎样保证更新缓存成功
- 消息队列重试机制。
- 订阅 MySQL binlog，再操作缓存。
1) 消息队列重试机制
- 引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。 
- 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。
- 当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。 
- 如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。
缺点是:对代码入侵性比较强，因为需要改造原本业务的代码。
![消息队列重试](images/%E7%BC%93%E5%AD%98-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%87%8D%E8%AF%95.webp)

2) 订阅 mysql binlog
- 「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。 
- 于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，
- 阿里巴巴开源的 Canal 中间件就是基于这个实现的。 Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。 下图是 Canal 的工作原理：
![Canal](images/%E7%BC%93%E5%AD%98-canal.webp)
- 前面说到直接用消息队列重试机制方案的话，会对代码造成入侵，
- 那么 Canal 方案就能很好的规避这个问题，因为它是直接订阅 binlog 日志的，和业务代码没有藕合关系，因此我们可以通过 Canal+ 消息队列的方案来保证数据缓存的一致性。 
- 具体的做法是：将binlog日志采集发送到MQ队列里面，然后编写一个简单的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性 
- 这里有一个很关键的点，必须是**删除缓存成功，再回 ack 机制**给消息队列，否则可能会造成消息丢失的问题，比如消费服务从消息队列拿到事件之后，直接回了 ack，然后再执行删除缓存操作的话，如果删除缓存的操作还是失败了，那么因为提前给消息队列回 ack了，就没办重试了。 
- 所以，如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用：
  - 消息队列来重试缓存的删除，优点是保证缓存一致性的问题，缺点会对业务代码入侵 
  - 订阅 MySQL binlog + 消息队列 + 重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题，缺点就是引入的组件比较多，对团队的运维能力比较有高要求。 这两种方法有一个共同的特点，都是采用异步操作缓存。


#### 问题
- 「先更新数据库，再删除缓存」的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。
- 所以，如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。
  
更新数据库 + 更新缓存产生的数据不一致问题怎么解决？
- 在更新缓存前先加个**分布式锁**，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。 
- 在更新完缓存时，给缓存加上**较短的过期时间**，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。

