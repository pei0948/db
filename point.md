# 数据库相关的知识点

### 常见数据模型
> 1、层次模型：在层次模型中，记录被组织为**树**的形式。树中的每个节点，表示一个实体（相当于一个表）。
> - a.根节点没有父节点；
> - b.除根节点以外的其他节点，有且仅有一个父节点 
> 
> 2、网状模型：在网状模型中，记录被组织为**有向图**的形式。图中的每个节点，表示一个实体（相当于一个表），实体之间的关系在底层中可由指针实现。
> - a.允许一个以上的节点没有父节点;
> - b.一个节点可以拥有多个父节点 
> 
> 3、关系模型：在关系模型中，用表表示实体和实体间的联系 

https://blog.csdn.net/gengkui9897/article/details/89295649

### 非关系型数据库和关系型数据库区别，优势比较？
> 1）关系型数据库将记录和记录之间的关系存入**表**中，
> 优点：
> - a.易于维护，都是使用表结构，格式一致       
> - b.使用方便，SQL语言通用，可用于复杂查询       
> - c.支持复杂操作，支持SQL，可用于一个表及多个表之间非常复杂的查询 
> 
> 缺点：
> - a.读写性能比较差，尤其是海量数据的高效率读写
> - b.固定的表结构，稍微欠缺灵活性       
> - c.高并发读写需求，就传统关系型数据库来说，硬盘I/O是一个很大的瓶颈 
>
> 2）非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等，
> 优势：       
> - a.格式灵活，存储数据的格式可以是key-value形式，文档形式，图片形式等，使用灵活，应用场景广泛，而关系型数据库只支持基础类型       
> - b.速度快，nosql可以使用硬盘或者内存作为载体，而关系型数据库只能使用硬盘       
> - c.高扩展性       
> - d.成本低，nosql数据库部署简单，基本都是开源软件 
> 
> 缺点：       
> - a.不支持sql，学习和使用成本较高       
> - b.无事务处理       
> - c.数据结构相对复杂，稍微欠缺复杂查询

### 数据库连接是TCP还是UDP？
> - TCP
> - 默认端口号3306

### 数据库范式？
> 1. 第一范式：列不可分，数据库中的所有字段都是不可分解的原子值（例如，地址可分为，国家，城市，县区等，可分割，不满足第一范式） 
> 2. 第二范式：在第一范式基础上，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键）。也就是说，在一个数据库表中，一个表只能保存一种数据，不可以把多种数据保存在同一张表中 
> 3. 第三范式：无传递性依赖。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能是间接相关。（例如，学生表，有学院，学院地址，学院电话等，学院与主键相关，但是学院地址和学院电话等只与学院相关，与主键无关，因此不满足第三范式）

https://zhuanlan.zhihu.com/p/128546246

### 数据库三级模式？
> 1. 面向用户或应用程序员的用户级，对应于外模式 
> 2. 面向建立和维护数据库人员的概念级，对应模式（又叫概念模式，逻辑模式） 
> 3. 面向系统程序员的物理级，对应内模式 

https://blog.csdn.net/qq_42175113/article/details/82831884

### 什么是临时表？临时表什么时候删除？
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除临时表，并释放空间。因此，在不同的连接中，可以创建同名的临时表，并且操作属于本连接的临时表 
> 删除： 
> - 1）关闭连接时，Mysql会自动删除临时表，并释放空间 
> - 2）手动删除（DROP TEMPORARY TABLE IF EXISTS tmp_tb）; 创建临时表与创建普通表类似，只是多了TEMPORARY关键字： CREATE TEMPORARY TABLE tmp_tb(...); 

https://www.cnblogs.com/wenxiaofei/p/9853682.html

### 数据库的主从复制方式？
> 1. 同步复制：master(主数据库)的变化，必须等待slave-1(从数据库-1)，slave-2,...,slave-n完成后才能返回。这样不可取，也不是Mysql复制的默认设置，比如（在WEB前端页面上，用户增加了一条数据，需要等待很长时间） 
> 2. 异步复制：master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志（bin-log文件，存储主库执行过的sql语句的二进制），是否完成操作，不用关心。该项为Mysql的默认设置 
> 3. 半同步复制：master只保证slaves中的一个操作成功，就返回，其他slaves不管。该功能为google引入mysql的

### 数据库主从复制的7个问题？
> 1）是否可以向slave进行写操作？
> - 不可以。如果slaves可以进行写操作，slave又无法通知到master，这样使得master和slave数据不一致。 
>
> 2）slave能够带来哪些好处？
> - a.数据备份。一旦master出现问题，可以让slave顶上去，提升slave为master       
> - b.负载均衡。通过服务器复制功能，可以在主服务器与从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询，从而得到更好地客户响应时间 
> 
> 3）主从复制中，有多个slave，JAVA WEB应用应该选择哪个数据库？       
> - 应用程序承担SQL语句的路由。insert/delete/update这些更新操作，用connection(for master)进行，select用connection(for slaves)进行操作。这样可能会出现这样的问题：如果master坏掉了，或者一些slave坏掉了，那么就需要更改应用程序。       
> - 2）利用相应组件承担SQL语句的路由。由一些组件（比如haproxy）承担SQL语句的路由 
>
> 4）如果mysql proxy,direct,master中的一些坏掉了，怎么办？       
> - 可以给某些关键节点做备份 
> 
> 5）存在N个slave，master在发送二进制日志时，是否一定需要发送N次？       
> - 不一定。如果发送N次，master内部需要维护N个线程，每个线程负责将二进制日志文件发往对应的slave，master既要负责写操作，还需要维护N个线程负担太重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主服务器，slave-1将master的复制线程的负担转移到自己身上，这就是所谓的多级复制的概念。 
> 
> 6）当一个select发往Mysql proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了？
> - 应该找一个共享式的缓存，比如memcache解决，将slave-2,slave-3，。。。这些查询的结果都缓存至memcache中 
> 
> 7）随着应用的日益增多，读操作很多，可以扩展slave，但是如果master满足不了写操作了，该怎么办？      
> - a）将master换做更好的服务器      
> - b）可以分库（垂直拆分），分表（水平拆分）

### 数据库分片、分区、分表、分库
> 切分的目的：减少数据库负担，缩短查询时间 数据切分有两种类型：
> - 垂直切分
> - 水平切分

> 垂直切分
> 1. 垂直分库
> - 垂直分库：根据业务耦合性，将关联度低的不同表存储在不同的数据库。  
> 
> 2. 垂直分表 
> - 垂直分表：基于数据库中的列进行。某个表字段较多，可以新建一张扩展表，将不经常用或字段较大的字段拆分出去到扩展表中。

当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈时，这时候就需要进行水平切分了
> 水平切分
> 1. 库内分表
> - 根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小。
> 
> 2. 分库分表
> - 将库内分表分得的表存储在不同的数据库上

### Mysql高并发环境解决方案？
> 分库，分表，分布式，增加二级缓存 
> 
> 需求分析：互联网单位，每天大量数据读取，写入，并发性高 
> - 现有解决方案：水平分库、分表，由单点分布到多点数据库中，从而降低单点数据库压力 
> - 集群方案：解决数据库宕机带来的单点数据库不能访问的问题
> 
> 读写分离策略：极大限度提高了应用中read数据的速度和并发量，无法解决高写入压力

### 数据库崩溃时事务的恢复机制？ （REDO日志和UNDO日志）
> 1. Undo log：Undo log是为了实现事务的原子性。在Mysql数据库InnoDB存储引擎中，还用了Undo log来实现多版本并发控制（MVCC）      
> - 原理：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo log），然后进行数据修改，如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到开始之前的状态。 
> 
> 2. Redo log:      
> - 原理：和Undo log相反，Redo Log记录的是新数据的备份，在事务提交前，只要将Redo log持久化即可，不需要将数据持久化，当系统崩溃时，虽然数据没有持久化，但是Redo log已经持久化，系统可以根据Redo log的内容，将所有数据恢复到最新的状态

### 主键
> 主键的完整名称为主键约束，是一个列或者几个列的组合，其值非空，能够唯一地标识表中的每一行

### 外键
> 一个表中的列，是另一个表的主键，该列被称为外键

### 超键
> 在关系数据库中，能唯一标识元组的属性集称为超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。例如，学生表中，有学号，姓名，性别，生日等字段，学号是唯一的，可以标识这名学生，可以作为一个超键，同时姓名，性别，生日的组合也是唯一的，可以标识这名学生，因此也可以作为一个超键。

### 候选键
> 候选键是在超键基础上定义的，在要求可以区分每一行基础上，是最小的，唯一的，即删除键中任何一个属性后就不能再区分该记录行

### 为什么用自增列作为主键？
> 1. 如果使用自增主键，则每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 
> 2. 如果使用非自增主键，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新纪录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又需要将该页数据从磁盘读入，增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

### 主键索引，主键和唯一索引的区别
> 主键索引指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键时，数据库默认会为主键创建一个唯一索引

### 唯一索引
> 索引列的值唯一，允许存在空值

### 主键和唯一索引
1. 主键一定是唯一索引，但是唯一索引不一定是主键 
2. 主键列不允许空值，唯一性索引允许存在空值 
3. 一个表中可以有多个唯一索引，但只能有一个主键

### 主键就是索引吗？
> 主键是索引

### 联合索引？ index(a, b, c)，SELECT *  FROM t WHERE t.a = 'x' AND t.c = 'X' 走索引吗？
>

### 触发器的作用？
> 当特定的事件发生时，对触发条件进行检查，如果满足触发条件，则执行触发器内的定义的动作

### 什么是存储过程？用什么调用？
> - 存储过程是具有特定功能的，预编译过的，存储在数据库中的一段SQL语句的集合。存储过程像方法一样，有自己的名字，内部由SQL语句组成。
> - 调用存储过程： 1）通过CALL+存储过程名字 2）供外部程序调用，比如：java程序

### 存储过程的优缺点？
- 优点： 
1. 存储过程只在创建时进行编译，以后每次执行存储过程都不需要重新编译，而一般的SQL语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率 
2. 当需要的功能有变化时，可以只修改数据库中的存储过程，而不用修改代码 
3. 减少网络传输，在客户端调用一个存储过程，比执行一串SQL传输的数据量要小 
4. 通过存储过程能够使得没有权限的用户在控制之下间接地存取数据库，从而确保数据安全 
5. 存储过程可重复使用，减少数据库开发人员开发量 

- 缺点： 
1. 调试麻烦 
2. 移植性差 
3. 维护麻烦。如果一个程序系统中使用了大量的存储过程，到程序交付使用时，用户需求的增加，会导致数据结构发生变化，就需要更改存储过程，维护起来就十分麻烦。

### 什么是视图？什么是游标？
1. 视图：是一种虚拟的表，具有和物理表相同的功能，实际上为一条SQL语句。对视图的修改**不会**影响基本表。 
2. 游标：有时，需要在检索出来的行中前进或者后退一行或多行，这就用到了游标。游标是一个存储在Mysql服务器上的数据库查询，它不是一条SELECT语句，而是被该语句**检索出来的结果集**。在存储了游标后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

### 视图的优缺点？
- 优点： 
1. 简化查询语句，用户通过简单查询便可得到复杂查询得到的结果 
2. 引入视图可以提高数据的安全性。可以对不同的用户定义不同的视图，使得机密数据不出现在不应看到这些数据的用户视图上。这样，视图机制就自动提供了对机密数据的安全保护功能。 

- 缺点：

### 如何删除视图？
> DROP VIEW 视图名字

### SQL语言分类？
1. 数据查询语言DQL       DQL基本结构为，由SELECT,FROM,WHERE子句组成的查询块 
2. 数据操纵语言DML       插入（INSERT）,更新（UPDATE）,删除（DELETE)子句 
3. 数据定义语言DDL      数据定义语言用来创建数据库中的各种对象——表，视图，索引，同义词，聚簇等      DDL操作是隐形提交的，不能rollback 
4. 数据控制语言DCL      数据控制语言用来授予或回收数据库的某种权限，并控制数据库操纵事务发生的时间及效果，对数据库实行监视，如：GRANG, ROLLBACK [WORK] TO [SAVEPOINT], COMMIT

### Mysql如何执行查询的？
1. 客户端向Mysql服务器发送一条查询请求 
2. 服务器首先检查查询缓存，如果命中缓存，立刻返回存储在缓存中的结果，否则执行3） 
3. 解析器根据 SQL 生成语法树，预处理器利用语法树检查 SQL 语句语法，优化器生成对应的执行计划 
4. Mysql根据执行计划，调用存储引擎API执行查询 
5. 将结果返回给客户端，同时缓存查询结果

https://blog.csdn.net/zzmian/article/details/93489188

### 为什么用数据库连接池？
1. 资源重用：由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗基础上，同时，增进了系统环境的平稳性（减少内存碎片以及数据库临时进程、线程数量） 
2. 更快的系统响应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池内备用，此时连接池的初始化操作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩短了系统整体响应时间 
3. 统一的连接管理，避免数据库连接泄露：在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用的连接，从而避免了常规数据库连接操作中可能出现的资源泄露

### 查询语句不同元素（where, join, limit, group by, having等）执行先后顺序？
FROM - ON - JOIN - WHERE - GROUP BY - WITH - HAVING - SELECT - DISTINCT - ORDER BY - LIMIT

### drop, truncate, delete的区别？
1. drop直接删掉表 
2. truncate删除表中数据，不删除表结构，再插入时自增长id又从1开始 
3. delete删除表中数据，删除行记录，可以添加where子句

### %和 _的区别？
- %：表示任何字符出现任意次数（可以是0次），但不能匹配NULL（LIKE '%'无法匹配到NULL） 
- _：只能匹配单个字符

### Count(*)，Count(1)和Count(column)的区别？
- Count(*)：对行的数目进行计算，包含NULL 
- Count(column)：对特定的列的行数进行计算，不包含NULL值 
- Count(1)与Count(*)结果是一样的

### 什么是内连接，外连接，交叉连接，笛卡尔积？
1. 内连接(INNER JOIN)：查询匹配的行 
2. 左外连接(LEFT OUTER JOIN)：包含左边表的全部行，和右边表中全部匹配的行，不管左边的表中的行是否与右边表中的行匹配 
3. 右外连接(RIGHT OUTER JOIN)：包含右边表的全部行，和左边表中全部匹配的行，不管右边的表中的行是否与左边表中的行匹配 
4. 全外连接（FULL OUTER JOIN）：包含左右两个表的全部行，不管另一边的表中是否存在与它们匹配的行 
5. 交叉连接（CROSS JOIN）：生成笛卡尔积，不使用任何匹配或者选取条件，而是将一个表中的每一行与另一个表中的每一行都一一匹配

### varchar和char的使用场景？
1. char长度不可变，varchar长度可变。例如，定义char(10), varchar(10),存入‘csdn’，char所占长度依然是10，除了字符‘csdn’外，后面跟上六个空格，varchar则是将长度变为4。取数据时，char类型的，需要用trim()去掉前后多余的空格，varchar不需要 
2. char的长度固定，varchar长度不固定，因此char的存取速度要比varchar快得多。 
3. char存储方式是：英文字符（ASCII）占用一个字节，一个汉字占用两个字节 
4. 两者的存储数据都是非unicode的字符数据

### 怎样使用explain优化sql和索引？
对于复杂、效率低的sql语句，我们通常使用EXPLAIN SQL分析sql语句，这个语句可以打印出语句执行的相应情况，方便我们分析，优化 相关项解释： 
1. table：显示sql语句是关于哪张表的 
2. type：显示连接用了哪种类型。最好到最差的连接类型为：const, eq_ref, ref, range, index和ALL                 
   - a）ALL：全表扫描，MySQL将遍历全表以找到匹配的行                 
   - b）index：扫描**索引的全部内容**来满足查询，而不是根据条件选择性地查找特定值，应用于查询涉及的列都可以通过索引来获取时：EXPLAIN SELECT email FROM users;
   - c）range：索引范围扫描，对索引的扫描开始于某一点，返回匹配的行，常出现在between等查询                 
   - d）ref：非唯一性索引扫描，根据条件筛选索引中的部分数据
   - e）eq_ref：唯一性索引扫描。对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描                 
   - f）const：当MySQL对某查询的某部分进行优化时，并转化为一个常量时，使用这些访问类型。如果将主键置于WHERE列表中，MySQL就能将该查询转化为一个常量 
3. possible_keys：显示可能应用于该查询的索引。如果为空，则没有可用的索引。 
4. key：实际使用的索引。如果为NULL，则没有使用索引。 
5. key_len：使用索引的长度。在不损失精确性的情况下，长度越短越好
6. ref：显示索引的哪一列被使用了，如果可能的话，是一个常数 
7. rows：MySQL认为必须检查的行数 
8. Extra:关于Mysql如何解析查询额外信息。
https://blog.csdn.net/weixin_52448922/article/details/120790880


### Mysql慢查询怎么解决？
1. 查看slow_query_log日志，查看慢查询开启状态 
2. slow_query_log_file慢查询日志存放的位置，查看慢查询日志 
3. long_query_time，查询超过多少秒才可以被记录

### 最左前缀原则？
创建多列索引（col1, col2, col3）,则相当于创建了索引（col1）, (co1, col2), (col1, col2, col3)

### 什么是索引？
索引是数据库表中一个排序的**数据结构**，以协助快速查询、更新数据表中数据。索引的实现通常为B树或者B+树。有了索引，存储引擎不会再去扫描整张表查找需要的数据，而是从根节点开始，依次查找相应的数据

### 索引的作用？索引的优缺点是什么？
- 优点： 
1. 加快数据的检索速度，这也是创建索引最主要的原因 
2. 加速表和表之间的连接，特别是在实现数据的参考完整性方面很有意义
3. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间 
4. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性 

- 缺点： 
1. 时间方面：创建索引和维护索引需要耗费时间。具体地，当对表中的数据增加、删除和修改时，索引也要动态地维护，降低了数据维护的效率 
2. 空间方面：索引需要占物理空间

### 哪些列适合建立索引？哪些列不适合建立索引？创建索引时应该注意什么？
不适合建立索引的列： 
1. 对于那些在查询中很少使用的列不应该创建索引；（这些列很少被使用，因此有无索引，性能提高的意义不是很明显，相反，增加了索引，反而降低了系统的维护性能，增加空间需求） 
2. 当修改性能比检索性能更重要时，不应该创建索引。（修改性能和检索性能是互相矛盾的，增加索引时，会提高检索性能，但是会降低修改性能，当减少索引时，会提高修改性能，降低检索性能。因此，当需要经常修改表中数据时，不应该创建索引） 
3. 对于那些只有很少数据值的列，也不应该创建索引。（这些列的取值很少，例如人事表的性别，在查询结果中，需要在表中搜索的数据行的比例很大，增加索引，并不能明显加快检索速度） 
4. 对于那些定义为text， image，和bit数据类型的列，不应该增加索引。（这些列的数据量要么相当大，要么取值很少）

### 什么情况下设置了索引却无法使用？
1. 以‘%’（表示任意0个或多个字符）开头的LIKE语句，**模糊匹配**
2. **OR语句**前后没有同时使用索引
3. 数据类型出现**隐式转换**（如果索引字段的数据类型与查询条件的数据类型不匹配，数据库可能会对字段进行隐式转换，从而导致索引失效） 
4. 对于多列索引，必须满足**最左匹配原则**（多列索引（col1, col2, col3），则索引生效的情况包括（col1）或者（col1, col2）或者（col1, col2, col3））
5. **对索引列使用函数**：如果在查询条件中对索引列应用了函数（例如 LOWER()、UPPER()、DATE() 等），索引将无法正常工作，因为函数的计算结果无法直接使用索引。
6. **对索引列进行算术运算**：如果在查询条件中对索引列进行了算术操作，如加减乘除，索引将失效。
7. **使用 != 或 <、> 等不等运算符**：这些操作符可能导致索引失效，因为数据库无法通过索引快速定位符合条件的行。
8. **使用范围条件后续字段无法利用索引**：如果在复合索引中，使用了范围查询（如 BETWEEN、>、<），那么该索引后续的字段将无法继续使用索引。


### 索引分类？
1. 普通索引和唯一索引：索引列的值的唯一性 
2. 单个索引和符合索引：依据索引列包含的列数是否唯一 
3. 聚集索引和非聚集索引

### 索引有哪些数据结构？
B树，B+树，hash表

### B树和B+树的区别？
1. B 树非叶子结点存储数据,因此查询数据时，时间复杂度最好为 O(1),最坏为 O(log n)。
2. B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。
3. B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历。

### B树和红黑树？
红黑树每个节点只有左右两个子节点，树的深度过大，造成磁盘IO读写过于频繁，进而效率低下，而B树可以有多个子女，减少树的高度，提高查询效率

### 文件索引和数据库索引为什么使用B+树而不是B树？
1. B+树的磁盘读写代价更低。B+树内部节点没有存储数据，因此其内部节点相对B树更小。将存放数据的指针的空间省下来，存放关键字，相同空间可以存放更多关键字，相对来说IO读写次数也就降低了
2. B+树的查询效率更加稳定。任何关键字的查找都需要走一条从根节点到叶子节点的查找路径，因此，所有关键字的查找路径相同，因此，查找每一个关键字的效率相当 
3. B+树，只要遍历叶子节点就可实现所有表记录的遍历，而B树只能中序遍历，效率较低，数据库中，基于范围的查询是非常频繁的，因此B+树更加适合。

### MySQL B+Tree索引和Hash索引的区别？
1. hash索引只能够满足“=”，“IN”等等值查询，不能使用范围查询。索引键经过哈希后，索引键的大小关系并不能保证，因而查询某一范围的键值对应的记录效率较低。而B+树，只需要遍历其叶子节点即可 
2. hash索引在键值的排序操作方面表现不是很好 
3. hash索引无法进行部分索引查询。对于组合索引，hash索引在计算hash值时，将索引键合并后，再计算哈希值，如果对索引中的部分列进行查询，无法利用哈希索引
4. hash索引遇到大量哈希值相等情况时，产生哈希碰撞，效率不高

### 什么是事务？
事务是一个不可分割的数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。执行的结果必须使得数据库从一个一致性状态变到另一种一致性状态

### 分布式事务？
https://blog.csdn.net/suchahaerkang/article/details/81407308

### 事务四大特性(ACID)？
1. 原子性(A)：事务包含的所有操作，要么全部成功，要么全部失败回滚 
2. 一致性(C)：事务总是从一个一致性状态转换到另外一个一致性状态。比如A向B转账后，系统崩溃，不可能A扣了钱，B却没收到 
3. 隔离性(I)：多个用户并发访问数据库时，比如操作同一张表时，数据库为每个用户开启的事务，不能被其它事务的操作所干扰，多个并发的事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有干扰。一个事务所做的修改，在没有提交前对其他事务是不可见的。比如A正从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账 
4. 持久性(D)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

### 保持数据库一致性的方法？
https://blog.csdn.net/lyfqyr/article/details/83351594 
1. 尽可能使用约束，如外键，主键，非空字段等约束 
2. 使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整性和一致性 
3. 自写业务逻辑，这种方法相对麻烦，编程复杂，效率低下

### 事务的并发问题？
1. 脏读：事务可以读取未提交的数据。即，事务中的修改，即使没有提交，对其他事务也都是可见的 
2. 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新，并提交，导致事务A多次读取同一数据时，结果不一致
3. 幻读：当A事务读取某个范围内的记录后，B事务又在该范围内插入了新的记录，A事务再次读取该范围的记录时，发现和前一次读取到的数据不一样。 
备注：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于插入或删除，解决不可重复读，只需要锁住满足条件的行即可，解决幻读，则需要锁住相应表。

### 事务隔离级别？每个级别会引发什问题？MySQL默认是哪个级别？
1. 未提交读：事务中的修改，即使没有提交，对其他事务也都是可见的。可能产生的问题有：脏读，不可重复读，幻读 
2. 提交读：一个事务开始时，只能看见已经提交的事务所做的修改。可能产生的问题：不可重复读，幻读 
3. 可重复读：在同一个事务中，多次读取同样的记录，结果是一致的。可能产生的问题：幻读 
4. 可串行化：最高的隔离级别。强制事务串行执行，避免了脏读，不可重复读，幻读问题。可串行化在读取的每一行数据上都加锁，可能产生的问题：大量的超时和锁争用问题。

### 事务传播行为
1. PROPAGATION_REQUIRED：如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务，该设置是最常用的设置 
2. PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行 
3. PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常 
4. PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务 
5. PROPAGATION_NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则抛出异常 
6. PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常 
7. PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作

### 嵌套事务
嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫 save point，然后执行子事务，这个子事务的执行也是父事务的一部分。子事务结束后，父事务继续执行。

### 如果子事务回滚，会发生什么？
父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚

### 如果父事务回滚，会发生什么？
父事务回滚，子事务也跟着回滚。父事务结束之前，子事务是不会提交的。

### 子事务和父事务的提交顺序是什么？
子事务先提交，而后父事务再提交

### mysql都有什么锁？
1. 表锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低 
2. 行锁：开销大，加锁慢，会出现死锁。锁定粒度小，发生锁冲突的概率最低，并发度最高。 
3. 页面锁：开锁和加锁时间介于表锁和行锁之间。会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

### 死锁判定原理和具体场景？
两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。

### 死锁怎么解决？
1. 找出死锁进程，杀死进程（SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;） 
2. 设置锁的超时时间。 
3. 指定获取锁的顺序。

### 乐观锁和悲观锁（主要处理资源并发访问问题，实现并发控制）
1. 悲观锁 悲观锁的特点是先获取锁，再进行业务操作，即悲观地认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功，再进行业务操作。通常来讲，数据库上的悲观锁需要数据库本身提供支持，即通过常用的SELECT...FOR UPDATE操作来实现悲观锁。当数据库执行SELECT...FOR UPDATE时，会获取被SELECT中的数据行的行锁，因此其他并发执行的SELECT...FOR UPDATE试图获取相应行的行锁时，则发生排斥，需要等待行锁被释放，因此达到锁的效果。SELECT...FOR UPDATE获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 不同的数据库对SELECT...FOR UPDATE的实现和支持是有区别的，例如oracle支持SELECT...FOR UPDATE NO WAIT，表示如果拿不到锁，则立刻报错，而不是等待，MySQL则没有no wait这个选项。MySQL还有个问题，SELECT...FOR UPDATE 执行中，所有扫描过的行都会被锁上，这一点很容易产生问题。因此，如果MySQL中用悲观锁务必要确定使用了索引，而不是全表扫描。 
2. 乐观锁 乐观锁的特点是，先进行业务操作，只在最后实际更新数据时，进行检查数据是否被更新过，若未被更新过，则更新成功；若更新过，则失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持，一般的做法是在需要锁的数据上增加一个版本号或者时间戳。 其底层实现是这样的，在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时，再次获取版本号，对比两次获取的版本号，如果与之前获取的版本号相同，即可确认这期间没有发生并发的修改。如果更新失败，即认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，回滚整个业务操作，根据需要重试整个过程。

### 乐观锁和悲观锁的使用场景
一般情况下，读多写少的更适合用乐观锁，读少写多的更适合用悲观锁。乐观锁在不发生取锁失败时开销比悲观锁小，一旦发生失败，回滚开销则比较大。因此乐观锁适合用在取锁概率失败比较小的场景，提高系统并发性能。

### MyISAM和InnoDB的区别？
MyISAM采用的是非聚集索引，查找慢，增删快；InnoDB采用的聚集索引，查找快，增删慢
1. MYISAM 使用的是非聚集索引，数据和索引存储在不同的地方，通过 MYISAM 的索引，能够找到相应数据记录的地址，然后再根据地址找到相应数据，需要两次查询；InnoDB 使用的是聚集索引，数据和索引存储在相同的地方，需要一次查询。
2. MYISAM 的辅助索引和主键索引具有相同的地位，InnoDB 需要利用辅助索引找到相应的主键索引，然后再利用主键索引找到相应的数据。
3. 事务支持。MyISAM不支持事务，强调性能，每次查询具有原子性，执行速度比InnoDB快。InnoDB支持事务，具有事务提交，回滚和崩溃修复能力。 
4. 表锁差异。MyISAM只支持表锁。用户在操作MyISAM表时，执行SELECT, UPDATE, DELETE, INSERT语句时，都会给表加锁。InnoDB支持行级锁。行锁大幅度提高了多用户并发操作的性能。InnoDB的行锁，只是在主键WHERE时有效，非主键WHERE时锁全表。 
5. MyISAM不支持外键，InnoDB支持外键。 
6. 全文本索引。MyISAM支持FULLTEXT类型的全文本索引。InnoDB不支持FULLTEXT类型的全文本索引，但是InnoDB可以使用sphinx插件支持全文索引，并且效果更好。 
7. 表的总行数。MyISAM保存表的总行数，SELECT Count(*) FROM table;会直接取出该值。而InnoDB没有保存表的总行数，使用SELECT Count(*) FROM table;时会遍历整个表，消耗较大。但是加了WHERE条件后，MyISAM和InnoDB的处理方式一样。 
8. AUTO_INCREMENT。在MyISAM中，自动增长列可以和其他列一起建立索引，自动增长列必须是索引。如果是组合索引，自动增长可以不是第一列。InnoDB中，必须有自动只有自动增长列的索引，并且自动增长列必须是索引。如果是组合索引，必须是组合索引的第一列。 
9. 存储结构。每个MyISAM表在磁盘上存储成三个文件，第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，.myd存储数据，.myi存储索引。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件大小，一般为2GB 
10. 存储空间。MyISAM可被压缩，占据的存储空间较小，支持静态表，动态表，压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池，用于高速缓冲数据和索引。 
11. 可移植性、备份及恢复。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件，备份bin-log，或者用mysqldump，在数据量达到几十G的时候就相对痛苦了。 
12. CRUD：如果执行大量的SELECT，MyISAM是比较好的选择。如果数据需要执行大量的INSERT或UPDATE，出于性能考虑，应该使用InnoDB。DELETE，从性能说，InnoDB更优，但是，DELETE FROM table，InnoDB不会重新建表，而是一行一行删除，在InnoDB上，如果要清空保存有大量数据的表，最后使用truncate table


### nosql(not only SQL)分类？
https://www.cnblogs.com/mingzhang/p/9656129.html https://blog.csdn.net/alex_xfboy/article/details/82910080 
1. 列存储。按列存储数据，方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。常见数据库有Hbase, Cassandra, Hypertable 
2. 文档存储。文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。常见数据库有MongoDB, CouchDB 
3. key-value存储。可以通过key快速查询到value。一般来说，存储不管value的格式，照单全收。常见数据库有Redis，MemcacheDB，Berkeley DB，Tokyo Cabinet/Tyrant 
4. 图存储。图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，设计使用不方便。常见数据库有Neo4J, FlockDB 
5. 对象存储。通过类似面向对象语音的语法操作数据库，通过对象的方式存取数据。常见数据库有db4o, Versant 
6. xml数据库。高效的存储XMLA数据，并支持XML的内部查询语法。常见数据库有Berkeley DB XML, BaseX


### 数据类型
> - 保存字符串数据通常都使用 VARCHAR 和 CHAR 两种类型，前者通常称为变长字符串，而后者通常称为定长字符串；对于 InnoDB 存储引擎，行存储格式没有区分固定长度和可变长度列，因此 VARCHAR 类型和 CHAR 类型没有本质区别，后者不一定比前者性能更好。
> - 如果要保存的很大字符串，可以使用 TEXT 类型；
> - 如果要保存很大的字节串，可以使用 BLOB（二进制大对象）类型。在 MySQL 中，TEXT 和 BLOB又分别包括 TEXT、MEDIUMTEXT、LONGTEXT 和 BLOB、MEDIUMBLOB、LONGBLOB 三种不同的类型，它们主要的区别在于存储数据的最大大小不同。
> - 保存浮点数可以用 FLOAT 或 DOUBLE 类型，FLOAT 已经不推荐使用了，而且在 MySQL 后续的版本中可能会被移除掉。
> - 而保存定点数应该使用 DECIMAL 类型，它可以指定小数点前后有效数字的位数。
> - 如果要保存时间日期，DATETIME 类型优于 TIMESTAMP 类型，因为前者能表示的时间日期范围更大，后者底层其实就是一个整数，记录了指定的日期时间和 1970-01-01 00:00:00 相差多少个毫秒，该类型在 2038-01-19 03:14:07 之后就会溢出。

### 什么事务？
> - 一系列对数据库进行读/写的操作，这些操作要么全都成功，要么全都失败。

### 事务的 ACID 特性？
> - 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行
> - 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态
> - 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行
> - 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中

### 事务的隔离级别？
> - 读未提交（Read uncommitted）：一个事务可以读取另一个事务中尚未提交的数据
> - 读已提交（Read committed）：一个事务只能读取另一个事务已经提交的数据
> - 可重复读（Repeatable read）：在一个事务内，多次读取同一数据时，其值都相同
> - 可串行化（Serializable）：所有的事务依次逐个执行，没有并发操作

### 并发事务访问数据时，可能出现的三类问题？
> - 脏读（Dirty read）：一个事务读取到另一个事务未提交的数据
> - 不可重复读（Non-repeatable read）：一个事务在读取某些数据，多次读取同一个数据时，其值都不同
> - 幻读（Phantom read）：一个事务在读取了某个范围的数据后，另一个事务在该范围内插入了新的数据，并提交了事务，然后第一个事务再次读取相同的范围时，会发现有新插入的数据，导致读取结果与之前的读取结果不一致。

### 什么是聚集索引和非聚集索引？
> - 聚集索引（Clustered Index）和非聚集索引（Non-Clustered Index）是数据库中用于加快数据检索速度的索引类型，它们在数据存储和索引构建方式上有所不同。

1. 聚集索引（Clustered Index）：
- 聚集索引是按照索引键的顺序重新组织表中的行数据的索引。换句话说，聚集索引的叶子节点存储了整个数据行的数据。因此，每个表只能有一个聚集索引，通常是主键索引（Primary Key Index）。
- 聚集索引对于主键的查找非常高效，因为它直接将索引键映射到数据行，无需再次查找。但是，由于数据行的物理存储顺序与聚集索引的顺序相同，因此对于频繁的插入和更新操作，可能会导致数据页的频繁移动，引起性能问题。
2. 非聚集索引（Non-Clustered Index）：
- 非聚集索引是另一种常见的索引类型，它的叶子节点存储了主键值。这意味着非聚集索引和实际的数据行是分开存储的。
- 一个表可以有多个非聚集索引，它们可以加速基于不同列的检索操作。由于非聚集索引的叶子节点不存储实际的数据行，因此它对于查找主键和范围查找的效率相对较低，需要先通过索引查找到数据行的位置，然后再根据指针访问数据行。

### 辅助索引？回表操作？
非主键的列生成的索引，InnoDB叶子节点存储主键ID，使用该索引作为过滤条件，会先在该索引树上找到对应的主键值，然后根据主键的值，到聚集索引（或者非聚集索引）中找到真实的表数据行

### 索引设计原则
> - 最适合索引的列是出现在WHERE子句和连接子句中的列。
> - 索引列的基数越大（取值多、重复值少），索引的效果就越好。
> - 使用前缀索引可以减少索引占用的空间，内存中可以缓存更多的索引。
> - 索引不是越多越好，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。
> - 使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以主键要尽可能选择较短的数据类型，这样可以有效的减少索引占用的空间，提升索引的缓存效果。

### 什么是 Hive
> - 把 HDFS 中结构化的数据映射成表。
> - 通过把 HQL 进行解析和转换，最终生成一系列基于 Hadoop 的 MapReduce 任务或 Spark 任务，通过执行这些任务完成对数据的处理。也就是说，即便不学习 Java、Scala 这样的编程语言，一样可以实现对数据的处理。

### 当数据变化时，怎样更新缓存？
> - Cache Aside Pattern: 先更新数据库，再删除缓存。注意，不能够使用先更新数据库再更新缓存的方式，也不能够使用先删除缓存再更新数据库的方式
> - Read/Write Through Pattern: Read Through指在查询操作中更新缓存，也就是说，当缓存失效的时候，由缓存服务自己负责对数据的加载，从而对应用方是透明的；而Write Through是指在更新数据时，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存服务自己更新数据库（同步更新）
> - Write Behind Caching Pattern: 只更新缓存，不更新数据库，而缓存服务这边会异步的批量更新数据库。这种做法会大幅度提升性能，但代价是牺牲数据的强一致性。

更新缓存是应用程序性能优化中的一个重要问题，尤其是当数据频繁变化时。为了确保缓存中的数据始终是最新的，可以采用多种策略和模式来更新缓存。以下是一些常见的方法：

1. **缓存失效（Cache Invalidation）**

当数据发生变化时，主动使缓存失效，以便在下次请求数据时重新加载最新的数据。

**实现方法：**
- 在数据库写操作（如更新、删除、插入）之后，删除或更新相应的缓存条目。

2. **写通（Write-Through）缓存**

每次写操作（更新或插入）不仅更新数据库，还同时更新缓存。这确保了缓存和数据库中的数据始终一致。

3. **写回（Write-Behind）缓存**

写操作首先更新缓存，然后异步地将更改写回到数据库。这种方法可以提高写操作的性能，但存在数据一致性风险。


4. **时间驱动缓存（Time-to-Live, TTL）**

为缓存设置一个过期时间。当数据过期时，自动从缓存中删除，下次请求时重新加载数据。

5. **订阅/发布模式（Pub/Sub）**

当数据变化时，发布一个消息通知所有订阅者更新缓存。这种方法适用于分布式系统。

6. **双写（Dual Write）**

写操作同时更新数据库和缓存，读操作从缓存中读取数据。如果缓存未命中，则从数据库中读取并更新缓存。

7. **缓存标记**

使用特定的标记（如脏标记）来跟踪缓存数据是否与数据源同步。

7. **缓存更新策略的选择**

选择合适的缓存更新策略取决于具体的应用场景和需求：
- **数据更新频繁，读操作多**：考虑写通缓存或双写策略。
- **数据更新较少，读操作少**：可以使用缓存失效或时间驱动缓存。
- **分布式系统**：使用订阅/发布模式确保各节点缓存一致性。
- **性能和一致性权衡**：写回缓存提供更好的写性能，但可能会导致数据一致性问题。



### MVCC 是怎么实现的？
MySQL 的多版本并发控制（MVCC）主要是在 InnoDB 存储引擎中实现的，它通过保存数据的多个版本来处理并发读写操作，从而提高数据库的并发性能，并解决读写冲突的问题。以下是 MVCC 实现的主要机制:

1. **版本链（Version Chain）**：
   - 每个数据行都有一个版本链，版本链中保存了数据行的所有历史版本。
   - 每个版本都有一个时间戳标识，通常是事务ID的形式。

2. **Read-View（读视图）**：
   - 每个事务在启动时都会创建一个 Read-View，它记录了事务开始时的时间戳。
   - Read-View 决定了事务能够看到的数据版本的范围。

3. **写入操作**：
   - 当对数据行进行更新时，InnoDB 不会直接覆盖旧数据，而是创建该行数据的新版本，并将其添加到版本链中。
   - 旧版本数据会保留在版本链中，不会被覆盖。

4. **读取操作**：
   - 读取操作会根据事务的 Read-View 来选择合适的数据版本。
   - 如果数据版本的时间戳早于事务的 Read-View 时间戳，则该版本对事务可见。

5. **undo log（回滚日志）**：
   - InnoDB 使用 undo log 来记录行数据的历史版本，以便 MVCC 可以查询到历史数据。
   - 当事务回滚时，undo log 也用于恢复原始数据。

6. **系统版本号（System Version Number, SVN）**：
   - 每开启一个新的事务，系统版本号都会自动递增。
   - 事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

7. **隔离级别**：
   - MVCC 在 MySQL 中主要工作在可重复读（REPEATABLE READ）和提交读（READ COMMITTED）两种事务隔离级别下。
   - 在 READ UNCOMMITTED 隔离级别下，总是读取最新的数据行，而在 SERIALIZABLE 隔离级别下，会对所有读取的行都加锁。

8. **锁机制的补充**：
   - 虽然 MVCC 允许不加锁读取数据，但在某些情况下，如写入操作或特定隔离级别的事务，MySQL 仍然会使用锁机制来保证数据一致性。

通过这些机制，MVCC 能够在不阻塞读操作的情况下，处理写入操作，同时保持事务的隔离性和数据的一致性。这使得 MySQL 能够有效地处理高并发读写的场景。

**优点与缺点**
- 优点：
  - 高并发：MVCC 通过不加锁的读操作，提高了并发性能。
  - 一致性视图：提供一致性视图，使得事务在读取数据时不会受到其他事务的影响。
- 缺点：
  - 存储开销：维护多个数据版本和 Undo Log 需要额外的存储空间。
  - 复杂性：实现 MVCC 需要更复杂的机制来管理版本和事务。


### binlog 有几种模式？
MySQL 的 Binlog（Binary Log）有三种主要模式，分别是：

1. **Statement-Based Logging (SBR)**（基于语句的日志模式）
   - 在这种模式下，MySQL 会将执行的每一条 SQL 语句记录到 Binlog 中。当需要进行恢复或复制时，MySQL 会重新执行这些语句。
   - 优点：Binlog 较小，因为只记录了 SQL 语句。
   - 缺点：某些语句在不同的环境中执行可能产生不同的结果，尤其是涉及到非确定性函数（如 `NOW()`、`RAND()`）时。

2. **Row-Based Logging (RBR)**（基于行的日志模式）
   - 在这种模式下，MySQL 不记录 SQL 语句本身，而是记录每一行被修改的数据。也就是说，Binlog 中包含的是数据的具体变更，而非操作该数据的语句。
   - 优点：避免了 SBR 中某些语句可能产生不同结果的问题，适用于复杂的复制场景。
   - 缺点：Binlog 体积较大，因为记录了每一行的变更数据。

3. **Mixed Logging (MBR)**（混合日志模式）
   - 混合模式结合了 SBR 和 RBR 的优点，MySQL 会根据具体的 SQL 语句自动选择合适的日志模式。通常，它会使用基于语句的模式（SBR），但对于某些可能产生不确定性结果的语句，MySQL 会切换到基于行的模式（RBR）。
   - 优点：灵活性较高，既可以减少 Binlog 的大小，又可以避免 SBR 的潜在问题。
   - 缺点：逻辑复杂性较高。

你可以通过设置 `binlog_format` 参数来指定使用哪种模式：

- `binlog_format=STATEMENT`：使用基于语句的模式。
- `binlog_format=ROW`：使用基于行的模式。
- `binlog_format=MIXED`：使用混合模式。

一般来说，选择哪种模式取决于具体的应用场景和对数据一致性、性能的要求。


### 写数据时，undo log、redo log 和 binlog 的修改流程是怎样的？
在 MySQL 中，当执行写操作（如 `INSERT`、`UPDATE` 或 `DELETE`）时，涉及到多种日志，包括 Undo Log、Redo Log 和 Binlog。它们分别在不同的阶段和目的下被使用，以下是它们的修改流程：

1. **写入 Undo Log**
   - **作用**：Undo Log 用于回滚操作，确保当事务回滚时，可以将数据恢复到操作前的状态。
   - **流程**：
     1. 当事务开始修改数据前，MySQL 会先将数据的旧版本记录到 Undo Log 中。
     2. 如果事务回滚，MySQL 会使用 Undo Log 将数据恢复到旧版本。

   - **存储位置**：Undo Log 通常存储在内存和磁盘上的 `InnoDB` 表空间中。

2. **写入 Redo Log**
   - **作用**：Redo Log 用于崩溃恢复，保证在数据库崩溃后能够恢复事务的操作，从而实现事务的持久性（即 ACID 特性的 "D"）。
   - **流程**：
     1. MySQL 进行数据修改时，会将数据变更先记录到内存中的 `InnoDB` Buffer Pool 中。
     2. 同时，将数据修改记录（Redo Log）追加到 Redo Log Buffer 中。
     3. 这些日志记录可能会在事务提交之前刷入磁盘，这称为 "Write-Ahead Logging"。
     4. 当事务提交时，MySQL 会强制将 Redo Log Buffer 刷入磁盘（`ib_logfile` 文件），以确保数据变更记录已经持久化。

   - **存储位置**：Redo Log 被存储在 `InnoDB` 的日志文件中（如 `ib_logfile`）。

3. **写入 Binlog**
   - **作用**：Binlog 用于复制和数据恢复。它记录了所有对数据库数据的修改（针对整个数据库的），可以用于主从复制或数据恢复。
   - **流程**：
     1. 在事务执行的过程中，MySQL 会将 SQL 语句或其效果（基于 Binlog 模式）写入 Binlog 缓冲区。
     2. 当事务准备提交时，MySQL 会先写 Redo Log，然后将 Binlog 刷入磁盘（这是事务两阶段提交的一部分）。
     3. Binlog 成功写入后，MySQL 会提交 Redo Log，事务才算真正提交成功。

   - **存储位置**：Binlog 被存储在 MySQL 的二进制日志文件中，通常位于 MySQL 数据目录中。

**综合流程（事务两阶段提交）**
事务提交时，遵循两阶段提交的机制来确保 Binlog 和 Redo Log 的一致性：

1. **阶段 1：准备提交**
   - 先将所有变更记录写入 Redo Log，并标记为 "准备提交"（`prepare`）。
   - 将变更记录写入 Binlog 缓冲区。

2. **阶段 2：提交**
   - 将 Binlog 缓冲区的数据写入磁盘，并确保写入成功。
   - 将 Redo Log 标记为 "提交"（`commit`），并将这个标记写入磁盘。

通过这种机制，MySQL 确保了在崩溃恢复时，Binlog 和 Redo Log 的一致性，从而保障了数据的可靠性。

**顺序总结**
1. 事务开始时，先写 Undo Log，记录数据的旧版本。
2. 将数据的修改写入 Redo Log（日志先行机制）。
3. 将事务的变更记录写入 Binlog。
4. 提交事务时，先确保 Binlog 写入磁盘，再提交 Redo Log。

### 在两阶段提交过程中，如果写 binlog 过程中，数据库崩溃了会发生什么
- 如果在写入 Binlog 过程中崩溃，事务将被回滚。即使 Redo Log 已经写入并标记为准备提交，由于 Binlog 没有成功写入，数据库恢复时会判断事务未完成，从而回滚这个事务。

### mysql 有哪些崩溃场景，是怎样恢复的？
MySQL 崩溃后进行恢复的场景涉及多种情况，具体的恢复步骤和处理方法取决于崩溃发生的时机、使用的存储引擎（如 InnoDB）、日志类型（如 Redo Log 和 Binlog）等因素。以下是一些常见的崩溃恢复场景及其处理方式：

1. **崩溃发生在事务提交前**
   - **场景描述**：事务已经开始，但还未提交，数据库突然崩溃。
   - **恢复方式**：
     - **恢复过程**：由于事务未提交，InnoDB 会使用 Undo Log 回滚未完成的事务。这意味着所有未提交的修改将被撤销。
     - **结果**：数据库恢复到事务开始前的状态，未提交的数据不会保存。

2. **崩溃发生在事务的 Redo Log 标记为 `prepare` 之后，提交前**
   - **场景描述**：事务已经写入 Redo Log，并标记为“准备提交”（`prepare`），但尚未写入 Binlog，或者 Binlog 写入尚未完成。
   - **恢复方式**：
     - **恢复过程**：在崩溃恢复时，InnoDB 会扫描 Redo Log。如果发现有事务标记为“准备提交”，但没有完成提交，则该事务将被回滚。因为没有 Binlog 记录，意味着该事务不应该被认为是已提交的。
     - **结果**：事务回滚，数据恢复到事务开始前的状态。

3. **崩溃发生在 Binlog 写入过程中**
   - **场景描述**：事务已经准备提交，Redo Log 标记为 `prepare`，但在写入 Binlog 过程中发生崩溃。
   - **恢复方式**：
     - **恢复过程**：在数据库重启时，InnoDB 会检查 Redo Log。如果找到“准备提交”但缺少相应 Binlog 的事务，系统会回滚这些事务，以避免数据不一致。
     - **结果**：事务回滚，数据库保持一致性。

4. **崩溃发生在事务提交完成后**
   - **场景描述**：事务已成功提交，数据已写入 Binlog，Redo Log 也已标记为提交，随后数据库崩溃。
   - **恢复方式**：
     - **恢复过程**：在重启时，InnoDB 会应用已提交的 Redo Log，以确保所有提交的事务都被正确应用到数据文件中。因为事务已经提交，恢复过程不会回滚这些事务。
     - **结果**：事务提交的修改将被保留，数据库恢复到事务提交后的状态。

5. **MySQL 硬件崩溃导致数据文件损坏**
   - **场景描述**：硬件故障（如磁盘损坏）导致数据文件部分损坏或丢失。
   - **恢复方式**：
     - **恢复过程**：如果数据文件损坏，MySQL 可能无法启动。在这种情况下，管理员需要从备份中恢复数据，并应用最新的 Binlog 进行恢复。恢复过程通常包括以下步骤：
       - 从最近的完整备份恢复数据。
       - 使用 Binlog 重放自备份后的所有事务。
     - **结果**：数据库恢复到最近的可用状态。

6. **崩溃后 MySQL 无法启动**
   - **场景描述**：崩溃后 MySQL 无法启动，可能因为配置问题、日志文件损坏等原因。
   - **恢复方式**：
     - **恢复过程**：
       - 检查 MySQL 错误日志（`error.log`）以确定无法启动的原因。
       - 通过修复损坏的表、清理未完成的事务、修复损坏的日志文件等方式解决启动问题。
       - 必要时，使用备份数据和 Binlog 进行手动恢复。
     - **结果**：数据库恢复到稳定状态。

7. **崩溃后 MySQL 主从复制中断**
   - **场景描述**：主从复制过程中，主库或从库崩溃，导致复制中断或不一致。
   - **恢复方式**：
     - **恢复过程**：
       - 检查主库和从库的 Binlog 位置，确定复制中断点。
       - 在主库上获取从断点起的 Binlog，并手动重放到从库。
       - 如果从库严重不一致，可能需要重新同步主库和从库的数据。
     - **结果**：主从复制恢复，主从库保持一致性。

8. **系统崩溃导致内存数据丢失**
   - **场景描述**：系统崩溃导致未刷入磁盘的内存数据丢失。
   - **恢复方式**：
     - **恢复过程**：在恢复时，MySQL 会应用 Redo Log，将已提交但未刷入磁盘的事务重新应用到数据文件，确保数据一致性。
     - **结果**：已提交的事务不会丢失，数据库恢复到崩溃前的状态。

**总结**
- MySQL 使用多种日志（如 Undo Log、Redo Log 和 Binlog）以及备份机制来确保在崩溃后能够有效恢复数据。
- 不同的崩溃场景可能需要不同的恢复手段，包括自动恢复和手动干预。
- 崩溃恢复的目标是确保数据库的一致性和持久性，同时尽可能减少数据丢失。

### mysql 主从复制的过程是怎样的？
MySQL 主从复制是一种将主库（Master）上的数据和操作同步到从库（Slave）的机制。通过主从复制，多个从库可以保持与主库的数据一致性，并且支持读写分离、负载均衡和高可用性等场景。下面是 MySQL 主从复制的详细过程：

1. **主库（Master）上的操作**
   - **数据变更**：当在主库上执行写操作（如 `INSERT`、`UPDATE`、`DELETE`）时，MySQL 会首先记录这些操作到主库的二进制日志（Binlog）中。Binlog 记录了所有对数据库产生修改的 SQL 语句。

2. **从库（Slave）上的 I/O 线程**
   - **连接主库**：从库上的 I/O 线程（I/O Thread）连接到主库，并请求从指定的 Binlog 位置开始读取日志。
   - **拉取 Binlog**：I/O 线程会从主库读取 Binlog 的内容，并将这些日志传输到从库的中继日志（Relay Log）中。中继日志是从库上的一个本地文件，记录了从主库同步过来的 Binlog。

3. **从库上的 SQL 线程**
   - **读取中继日志**：从库的 SQL 线程（SQL Thread）会不断地读取中继日志中的内容。
   - **执行 SQL 语句**：SQL 线程会依次执行中继日志中的 SQL 语句，将这些操作应用到从库的数据中，从而使得从库的数据与主库保持同步。

4. **位置跟踪**
   - **主库的 Binlog 位置**：从库会记录当前同步的主库 Binlog 的文件名和位置（即 `log file` 和 `log position`），以便在复制过程中知道从哪里继续同步数据。
   - **从库的中继日志位置**：从库的 SQL 线程也会记录已经执行的中继日志的位置，以便在从库重启或中断后可以从正确的位置继续执行。

5. **同步完成**
   - **数据一致**：通过上述过程，主库的所有数据变更都会被从库逐步执行，从而实现主从数据的一致性。
   - **延迟问题**：在复制过程中，从库可能会出现一定的延迟，即从库的数据会比主库稍微滞后。延迟的大小取决于主库的负载、网络速度、从库的性能等因素。

6. **错误处理**
   - **跳过错误**：在从库执行 SQL 语句时，如果发生错误（如主库上执行成功的 SQL 语句在从库上失败），可以配置从库跳过错误继续执行（使用 `slave_skip_errors` 参数），但这可能会导致主从数据不一致。
   - **重新同步**：如果主从数据不一致，通常需要重新同步从库，可以通过全量备份主库并重新配置从库来实现。

**详细流程图解**
1. **主库写操作**：用户在主库上执行写操作（例如插入或更新数据）。
2. **主库记录 Binlog**：主库将这些操作记录到 Binlog 中。
3. **从库 I/O 线程**：从库的 I/O 线程连接到主库，读取 Binlog 并将其存储到从库的中继日志中。
4. **从库 SQL 线程**：从库的 SQL 线程读取中继日志，并依次执行其中的 SQL 语句，更新从库的数据。
5. **位置跟踪**：从库记录同步位置，以便在复制中断后能够从正确的位置继续。

**注意事项**
- **Binlog 格式**：主从复制依赖于主库的 Binlog，因此需要确保主库的 Binlog 已启用。Binlog 有三种格式：`STATEMENT`、`ROW` 和 `MIXED`，通常使用 `ROW` 格式来确保复制的准确性。
- **从库的配置**：从库需要配置主库的连接信息，包括主库的 IP 地址、用户名、密码等，并指定从哪个 Binlog 文件和位置开始复制。
- **主从一致性**：虽然主从复制可以确保数据的一致性，但在高负载下，可能出现短暂的延迟。为避免数据不一致，建议在某些情况下使用主从切换、读写分离等策略。

通过主从复制，MySQL 能够实现高可用性、负载均衡以及数据的实时备份，有助于提升数据库系统的可靠性和性能。

### 主库发生故障，怎样进行故障转移？
当 MySQL 主库发生故障时，进行故障转移（Failover）是确保系统持续可用的关键步骤。故障转移的目的是将从库提升为新的主库，并让其他从库继续与新主库同步。以下是执行故障转移的常见步骤：

1. **检测主库故障**
   - **自动监控**：使用监控工具（如 MHA、Orchestrator、ProxySQL）来自动检测主库故障。
   - **手动检测**：通过管理控制台或命令行工具（如 `mysqladmin ping`）检测主库的状态。

2. **选择新的主库**
   - **从库选择**：选择一个数据最接近主库的从库作为新的主库。通常选择延迟最小的从库。
   - **考虑数据一致性**：确保选择的从库已经应用了主库所有的 Binlog，这样可以最大程度保持数据一致性。

3. **将选定的从库提升为主库**
   - **停止复制**：在选定的从库上停止从主库的复制：
     ```sql
     STOP SLAVE;
     ```
   - **重置从库状态**：重置从库的复制状态，以确保其成为独立的主库：
     ```sql
     RESET SLAVE ALL;
     ```
   - **启用新的主库**：如果需要，可以修改 MySQL 的配置文件（如 `server-id`）以避免与其他从库冲突。

4. **重新配置其他从库**
   - **指向新主库**：将其他从库重新配置为从新的主库复制。对于每个从库，执行以下步骤：
     ```sql
     CHANGE MASTER TO
     MASTER_HOST='new_master_ip',
     MASTER_USER='replication_user',
     MASTER_PASSWORD='replication_password',
     MASTER_LOG_FILE='new_master_log_file',
     MASTER_LOG_POS=new_master_log_pos;
     START SLAVE;
     ```
   - **同步检查**：检查所有从库的复制状态，确保它们正常从新主库同步：
     ```sql
     SHOW SLAVE STATUS\G;
     ```

5. **更新应用程序配置**
   - **更改连接字符串**：将应用程序的数据库连接字符串指向新的主库。
   - **确保高可用性**：如果使用了中间层（如 ProxySQL 或 HAProxy），确保其配置更新，并指向新的主库。

6. **监控和验证**
   - **监控复制状态**：持续监控从库的复制状态，确保没有延迟或错误。
   - **验证数据完整性**：验证新的主库与旧主库的数据一致性，检查是否有丢失或损坏的数据。

7. **旧主库的恢复**
   - **修复旧主库**：在可能的情况下，尝试修复旧主库的故障，并将其重新加入复制拓扑作为从库。
   - **重新同步**：将旧主库作为新的从库进行同步，确保它与新主库的数据一致。
   - **备份和维护**：在修复之前，最好先对旧主库进行备份，避免进一步的数据损坏。

**自动化故障转移**
使用自动化工具可以简化故障转移的过程：
- **MHA (Master High Availability)**：一种用于 MySQL 主从架构下的高可用性管理工具，能够自动检测主库故障并执行故障转移。
- **Orchestrator**：MySQL 高可用性和复制拓扑管理工具，可以自动或手动执行故障转移。
- **ProxySQL/HAProxy**：作为数据库代理，可以在主库发生故障时自动切换流量到新的主库。

**总结**
- **检测和选择**：迅速检测故障并选择合适的从库作为新主库。
- **配置和同步**：配置新的主从关系，确保其他从库与新主库保持同步。
- **更新应用和验证**：更新应用程序连接，验证数据一致性和复制状态。
- **自动化工具**：使用自动化工具可以减少人工干预的风险和时间，确保故障转移的快速响应。

### 在故障转移过程中，读写会受到怎样的影响？
- 写操作暂停：在故障转移过程中，写操作通常会中断，直到新的主库接管。
- 读操作受限：读操作可能会暂时中断或重定向，但可能面临数据不一致的风险。
- 短暂不可用性：故障转移期间可能会有短暂的服务中断，具体时长取决于故障转移的效率和自动化工具的响应时间。
- 性能波动和延迟：故障转移完成后，系统性能可能会暂时波动，复制延迟可能加剧，尤其是在高负载环境中。

### InnoDB 的文件结构
InnoDB 是 MySQL 的默认存储引擎，它主要使用以下文件来管理数据和索引：
- .frm 文件：表的结构定义文件（已在 MySQL 8.0 中弃用）。
- .ibd 文件：InnoDB 专有的表空间文件，存储数据、索引等信息。
- ibdata 文件：默认的全局表空间文件，存储系统表数据和 undo log（可以通过 innodb_file_per_table 选项配置是否使用独立表空间）。
- Redo 和 Undo 日志文件：用于事务恢复和日志管理。

### MyISAM 的文件结构
MyISAM 是 MySQL 的旧存储引擎，主要使用以下文件来管理数据和索引：
- .frm 文件：表的结构定义文件。
- .MYD 文件：表的数据文件。
- .MYI 文件：表的索引文件，.MYI 文件存储 MyISAM 表的所有索引。
