# 数据库相关的知识点

### 常见数据模型
> 1、层次模型：在层次模型中，记录被组织为**树**的形式。树中的每个节点，表示一个实体（相当于一个表）。
> - a.根节点没有父节点；
> - b.除根节点以外的其他节点，有且仅有一个父节点 
> 
> 2、网状模型：在网状模型中，记录被组织为**有向图**的形式。图中的每个节点，表示一个实体（相当于一个表），实体之间的关系在底层中可由指针实现。
> - a.允许一个以上的节点没有父节点;
> - b.一个节点可以拥有多个父节点 
> 
> 3、关系模型：在关系模型中，用表表示实体和实体间的联系 

https://blog.csdn.net/gengkui9897/article/details/89295649

### 非关系型数据库和关系型数据库区别，优势比较？
> 1）关系型数据库将记录和记录之间的关系存入**表**中，
> 优点：
> - a.易于维护，都是使用表结构，格式一致       
> - b.使用方便，SQL语言通用，可用于复杂查询       
> - c.支持复杂操作，支持SQL，可用于一个表及多个表之间非常复杂的查询 
> 
> 缺点：
> - a.读写性能比较差，尤其是海量数据的高效率读写
> - b.固定的表结构，稍微欠缺灵活性       
> - c.高并发读写需求，就传统关系型数据库来说，硬盘I/O是一个很大的瓶颈 
>
> 2）非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等，
> 优势：       
> - a.格式灵活，存储数据的格式可以是key-value形式，文档形式，图片形式等，使用灵活，应用场景广泛，而关系型数据库只支持基础类型       
> - b.速度快，nosql可以使用硬盘或者内存作为载体，而关系型数据库只能使用硬盘       
> - c.高扩展性       
> - d.成本低，nosql数据库部署简单，基本都是开源软件 
> 
> 缺点：       
> - a.不支持sql，学习和使用成本较高       
> - b.无事务处理       
> - c.数据结构相对复杂，稍微欠缺复杂查询

### 数据库连接是TCP还是UDP？
> - TCP
> - 默认端口号3306

### 数据库范式？
> 1.第一范式：列不可分，数据库中的所有字段都是不可分解的原子值（例如，地址可分为，国家，城市，县区等，可分割，不满足第一范式） 
> 2.第二范式：在第一范式基础上，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键）。也就是说，在一个数据库表中，一个表只能保存一种数据，不可以把多种数据保存在同一张表中 
> 3.第三范式：无传递性依赖。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能是间接相关。（例如，学生表，有学院，学院地址，学院电话等，学院与主键相关，但是学院地址和学院电话等只与学院相关，与主键无关，因此不满足第三范式）

https://zhuanlan.zhihu.com/p/128546246

### 数据库三级模式？
> 1.面向用户或应用程序员的用户级，对应于外模式 
> 2.面向建立和维护数据库人员的概念级，对应模式（又叫概念模式，逻辑模式） 
> 3.面向系统程序员的物理级，对应内模式 

https://blog.csdn.net/qq_42175113/article/details/82831884

### 什么是临时表？临时表什么时候删除？
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除临时表，并释放空间。因此，在不同的连接中，可以创建同名的临时表，并且操作属于本连接的临时表 
> 删除： 
> - 1）关闭连接时，Mysql会自动删除临时表，并释放空间 
> - 2）手动删除（DROP TEMPORARY TABLE IF EXISTS tmp_tb）; 创建临时表与创建普通表类似，只是多了TEMPORARY关键字： CREATE TEMPORARY TABLE tmp_tb(...); 

https://www.cnblogs.com/wenxiaofei/p/9853682.html

### 数据库的主从复制方式？
> 1）同步复制：master(主数据库)的变化，必须等待slave-1(从数据库-1)，slave-2,...,slave-n完成后才能返回。这样不可取，也不是Mysql复制的默认设置，比如（在WEB前端页面上，用户增加了一条数据，需要等待很长时间） 
> 2）异步复制：master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志（bin-log文件，存储主库执行过的sql语句的二进制），是否完成操作，不用关心。该项为Mysql的默认设置 
> 3）半同步复制：master只保证slaves中的一个操作成功，就返回，其他slaves不管。该功能为google引入mysql的

### 数据库主从复制的7个问题？
> 1）是否可以向slave进行写操作？
> - 不可以。如果slaves可以进行写操作，slave又无法通知到master，这样使得master和slave数据不一致。 
>
> 2）slave能够带来哪些好处？
> - a.数据备份。一旦master出现问题，可以让slave顶上去，提升slave为master       
> - b.负载均衡。通过服务器复制功能，可以在主服务器与从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询，从而得到更好地客户响应时间 
> 
> 3）主从复制中，有多个slave，JAVA WEB应用应该选择哪个数据库？       
> - 应用程序承担SQL语句的路由。insert/delete/update这些更新操作，用connection(for master)进行，select用connection(for slaves)进行操作。这样可能会出现这样的问题：如果master坏掉了，或者一些slave坏掉了，那么就需要更改应用程序。       
> - 2）利用相应组件承担SQL语句的路由。由一些组件（比如haproxy）承担SQL语句的路由 
>
> 4）如果mysql proxy,direct,master中的一些坏掉了，怎么办？       
> - 可以给某些关键节点做备份 
> 
> 5）存在N个slave，master在发送二进制日志时，是否一定需要发送N次？       
> - 不一定。如果发送N次，master内部需要维护N个线程，每个线程负责将二进制日志文件发往对应的slave，master既要负责写操作，还需要维护N个线程负担太重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主服务器，slave-1将master的复制线程的负担转移到自己身上，这就是所谓的多级复制的概念。 
> 
> 6）当一个select发往Mysql proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了？
> - 应该找一个共享式的缓存，比如memcache解决，将slave-2,slave-3，。。。这些查询的结果都缓存至memcache中 
> 
> 7）随着应用的日益增多，读操作很多，可以扩展slave，但是如果master满足不了写操作了，该怎么办？      
> - a）将master换做更好的服务器      
> - b）可以分库（垂直拆分），分表（水平拆分）

### 数据库分片、分区、分表、分库
> 切分的目的：减少数据库负担，缩短查询时间 数据切分有两种类型：
> - 垂直切分
> - 水平切分

> 垂直切分
> 1 垂直分库
> - 垂直分库：根据业务耦合性，将关联度低的不同表存储在不同的数据库。  
> 
> 2 垂直分表 
> - 垂直分表：基于数据库中的列进行。某个表字段较多，可以新建一张扩展表，将不经常用或字段较大的字段拆分出去到扩展表中。

当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈时，这时候就需要进行水平切分了
> 水平切分
> 1 库内分表
> - 根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小。
> 
> 2 分库分表
> - 将库内分表分得的表存储在不同的数据库上

### Mysql高并发环境解决方案？
> 分库，分表，分布式，增加二级缓存 
> 
> 需求分析：互联网单位，每天大量数据读取，写入，并发性高 
> - 现有解决方案：水平分库、分表，由单点分布到多点数据库中，从而降低单点数据库压力 
> - 集群方案：解决数据库宕机带来的单点数据库不能访问的问题
> 
> 读写分离策略：极大限度提高了应用中read数据的速度和并发量，无法解决高写入压力

### 数据库崩溃时事务的恢复机制？ （REDO日志和UNDO日志）
> 1）Undo log：Undo log是为了实现事务的原子性。在Mysql数据库InnoDB存储引擎中，还用了Undo log来实现多版本并发控制（MVCC）      
> - 原理：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo log），然后进行数据修改，如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到开始之前的状态。 
> 
> 2）Redo log:      
> - 原理：和Undo log相反，Redo Log记录的是新数据的备份，在事务提交前，只要将Redo log持久化即可，不需要将数据持久化，当系统崩溃时，虽然数据没有持久化，但是Redo log已经持久化，系统可以根据Redo log的内容，将所有数据恢复到最新的状态

### 主键
> 主键的完整名称为主键约束，是一个列或者几个列的组合，其值非空，能够唯一地标识表中的每一行

### 外键
> 一个表中的列，是另一个表的主键，该列被称为外键

### 超键
> 在关系数据库中，能唯一标识元组的属性集称为超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。例如，学生表中，有学号，姓名，性别，生日等字段，学号是唯一的，可以标识这名学生，可以作为一个超键，同时姓名，性别，生日的组合也是唯一的，可以标识这名学生，因此也可以作为一个超键。

### 候选键
> 候选键是在超键基础上定义的，在要求可以区分每一行基础上，是最小的，唯一的，即删除键中任何一个属性后就不能再区分该记录行

### 为什么用自增列作为主键？
> 1）如果使用自增主键，则每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 
> 2）如果使用非自增主键，每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新纪录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又需要将该页数据从磁盘读入，增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

### 主键索引，主键和唯一索引的区别
> 主键索引指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键时，数据库默认会为主键创建一个唯一索引

### 唯一索引
> 索引列的值唯一，允许存在空值

### 主键和唯一索引
> 1）主键一定是唯一索引，但是唯一索引不一定是主键 
> 2）主键列不允许空值，唯一性索引允许存在空值 
> 3）一个表中可以有多个唯一索引，但只能有一个主键

### 主键就是索引吗？
> 主键是索引

### 联合索引？ index(a, b, c)，SELECT *  FROM t WHERE t.a = 'x' AND t.c = 'X' 走索引吗？
>

### 触发器的作用？
> 当特定的事件发生时，对触发条件进行检查，如果满足触发条件，则执行触发器内的定义的动作

### 什么是存储过程？用什么调用？
> - 存储过程是具有特定功能的，预编译过的，存储在数据库中的一段SQL语句的集合。存储过程像方法一样，有自己的名字，内部由SQL语句组成。
> - 调用存储过程： 1）通过CALL+存储过程名字 2）供外部程序调用，比如：java程序

### 存储过程的优缺点？
- 优点： 
1）存储过程只在创建时进行编译，以后每次执行存储过程都不需要重新编译，而一般的SQL语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率 
2）当需要的功能有变化时，可以只修改数据库中的存储过程，而不用修改代码 
3）减少网络传输，在客户端调用一个存储过程，比执行一串SQL传输的数据量要小 
4）通过存储过程能够使得没有权限的用户在控制之下间接地存取数据库，从而确保数据安全 
5）存储过程可重复使用，减少数据库开发人员开发量 

- 缺点： 
1）调试麻烦 
2）移植性差 
3）维护麻烦。如果一个程序系统中使用了大量的存储过程，到程序交付使用时，用户需求的增加，会导致数据结构发生变化，就需要更改存储过程，维护起来就十分麻烦。

### 什么是视图？什么是游标？
- 1）视图：是一种虚拟的表，具有和物理表相同的功能，实际上为一条SQL语句。对视图的修改会影响基本表。 
- 2）游标：有时，需要在检索出来的行中前进或者后退一行或多行，这就用到了游标。游标是一个存储在Mysql服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

### 视图的优缺点？
- 优点： 
1）简化查询语句，用户通过简单查询便可得到复杂查询得到的结果 
2）引入视图可以提高数据的安全性。可以对不同的用户定义不同的视图，使得机密数据不出现在不应看到这些数据的用户视图上。这样，视图机制就自动提供了对机密数据的安全保护功能。 

- 缺点：

### 如何删除视图？
> DROP VIEW 视图名字

### SQL语言分类？
1）数据查询语言DQL       DQL基本结构为，由SELECT,FROM,WHERE子句组成的查询块 
2）数据操纵语言DML       插入（INSERT）,更新（UPDATE）,删除（DELETE)子句 
3）数据定义语言DDL      数据定义语言用来创建数据库中的各种对象——表，视图，索引，同义词，聚簇等      DDL操作是隐形提交的，不能rollback 
4）数据控制语言DCL      数据控制语言用来授予或回收数据库的某种权限，并控制数据库操纵事务发生的时间及效果，对数据库实行监视，如：GRANG, ROLLBACK [WORK] TO [SAVEPOINT], COMMIT

### Mysql如何执行查询的？
1）客户端向Mysql服务器发送一条查询请求 
2）服务器首先检查查询缓存，如果命中缓存，立刻返回存储在缓存中的结果，否则执行3） 
3）解析器根据 SQL 生成语法树，预处理器利用语法树检查 SQL 语句语法，优化器生成对应的执行计划 
4）Mysql根据执行计划，调用存储引擎API执行查询 
5）将结果返回给客户端，同时缓存查询结果

https://blog.csdn.net/zzmian/article/details/93489188

### 为什么用数据库连接池？
1）资源重用：由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗基础上，同时，增进了系统环境的平稳性（减少内存碎片以及数据库临时进程、线程数量） 
2）更快的系统响应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池内备用，此时连接池的初始化操作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩短了系统整体响应时间 
3）统一的连接管理，避免数据库连接泄露：在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用的连接，从而避免了常规数据库连接操作中可能出现的资源泄露

### 查询语句不同元素（where, join, limit, group by, having等）执行先后顺序？
FROM - ON - JOIN - WHERE - GROUP BY - WITH - HAVING - SELECT - DISTINCT - ORDER BY - LIMIT

### drop, truncate, delete的区别？
1）drop直接删掉表 
2）truncate删除表中数据，不删除表结构，再插入时自增长id又从1开始 
3）delete删除表中数据，删除行记录，可以添加where子句

### %和 _的区别？
- %：表示任何字符出现任意次数（可以是0次），但不能匹配NULL（LIKE '%'无法匹配到NULL） 
- _：只能匹配单个字符

### Count(*)，Count(1)和Count(column)的区别？
- Count(*)：对行的数目进行计算，包含NULL 
- Count(column)：对特定的列的行数进行计算，不包含NULL值 
- Count(1)与Count(*)结果是一样的

### 什么是内连接，外连接，交叉连接，笛卡尔积？
1）内连接(INNER JOIN)：查询匹配的行 
2）左外连接(LEFT OUTER JOIN)：包含左边表的全部行，和右边表中全部匹配的行，不管左边的表中的行是否与右边表中的行匹配 
3）右外连接(RIGHT OUTER JOIN)：包含右边表的全部行，和左边表中全部匹配的行，不管右边的表中的行是否与左边表中的行匹配 
4）全外连接（FULL OUTER JOIN）：包含左右两个表的全部行，不管另一边的表中是否存在与它们匹配的行 
5）交叉连接（CROSS JOIN）：生成笛卡尔积，不使用任何匹配或者选取条件，而是将一个表中的每一行与另一个表中的每一行都一一匹配

### varchar和char的使用场景？
1.char长度不可变，varchar长度可变。例如，定义char(10), varchar(10),存入‘csdn’，char所占长度依然是10，除了字符‘csdn’外，后面跟上六个空格，varchar则是将长度变为4。取数据时，char类型的，需要用trim()去掉前后多余的空格，varchar不需要 
2.char的长度固定，varchar长度不固定，因此char的存取速度要比varchar快得多。 
3.char存储方式是：英文字符（ASCII）占用一个字节，一个汉字占用两个字节 
4.两者的存储数据都是非unicode的字符数据

### 怎样使用explain优化sql和索引？
对于复杂、效率低的sql语句，我们通常使用EXPLAIN SQL分析sql语句，这个语句可以打印出语句执行的相应情况，方便我们分析，优化 相关项解释： 
1）table：显示sql语句是关于哪张表的 
2）type：显示连接用了哪种类型。最好到最差的连接类型为：const, eq_ref, ref, range, index和ALL                 a）ALL：全表扫描，MySQL将遍历全表以找到匹配的行                 b）index：只遍历索引                 c）range：索引范围扫描，对索引的扫描开始于某一点，返回匹配的行，常出现在between等查询                 d）ref：非唯一性索引扫描                 e）eq_ref：唯一性索引扫描。对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描                 f）const：当MySQL对某查询的某部分进行优化时，并转化为一个常量时，使用这些访问类型。如果将主键置于WHERE列表中，MySQL就能将该查询转化为一个常量 
3）possible_keys：显示可能应用于该查询的索引。如果为空，则没有可用的索引。 
4）key：实际使用的索引。如果为NULL，则没有使用索引。 
5）key_len：使用索引的长度。在不损失精确性的情况下，长度越短越好 
6）ref：显示索引的哪一列被使用了，如果可能的话，是一个常数 
7）rows：MySQL认为必须检查的行数 
8）Extra:关于Mysql如何解析查询额外信息。

### Mysql慢查询怎么解决？
1）查看slow_query_log日志，查看慢查询开启状态 
2）slow_query_log_file慢查询日志存放的位置，查看慢查询日志 
3）long_query_time，查询超过多少秒才可以被记录

### 最左前缀原则？
创建多列索引（col1, col2, col3）,则相当于创建了索引（col1）, (co1, col2), (col1, col2, col3)

### 什么是索引？
索引是数据库表中一个排序的**数据结构**，以协助快速查询、更新数据表中数据。索引的实现通常为B树或者B+树。有了索引，存储引擎不会再去扫描整张表查找需要的数据，而是从根节点开始，依次查找相应的数据

### 索引的作用？索引的优缺点是什么？
- 优点： 
1）加快数据的检索速度，这也是创建索引最主要的原因 
2）加速表和表之间的连接，特别是在实现数据的参考完整性方面很有意义
3）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间 
4）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性 

- 缺点： 
1）时间方面：创建索引和维护索引需要耗费时间。具体地，当对表中的数据增加、删除和修改时，索引也要动态地维护，降低了数据维护的效率 
2）空间方面：索引需要占物理空间

### 哪些列适合建立索引？哪些列不适合建立索引？创建索引时应该注意什么？
不适合建立索引的列： 
1）对于那些在查询中很少使用的列不应该创建索引；（这些列很少被使用，因此有无索引，性能提高的意义不是很明显，相反，增加了索引，反而降低了系统的维护性能，增加空间需求） 
2）当修改性能比检索性能更重要时，不应该创建索引。（修改性能和检索性能是互相矛盾的，增加索引时，会提高检索性能，但是会降低修改性能，当减少索引时，会提高修改性能，降低检索性能。因此，当需要经常修改表中数据时，不应该创建索引） 
3）对于那些只有很少数据值的列，也不应该创建索引。（这些列的取值很少，例如人事表的性别，在查询结果中，需要在表中搜索的数据行的比例很大，增加索引，并不能明显加快检索速度） 
4）对于那些定义为text， image，和bit数据类型的列，不应该增加索引。（这些列的数据量要么相当大，要么取值很少）

### 什么情况下设置了索引却无法使用？
1）以‘%’（表示任意0个或多个字符）开头的LIKE语句，模糊匹配 
2）OR语句前后没有同时使用索引
3）数据类型出现隐式转换（如varchar不加单引号的话可能会自动转换为int型） 
4）对于多列索引，必须满足最左匹配原则（多列索引（col1, col2, col3），则索引生效的情况包括（col1）或者（col1, col2）或者（col1, col2, col3））

### 索引分类？
1）普通索引和唯一索引：索引列的值的唯一性 
2）单个索引和符合索引：依据索引列包含的列数是否唯一 
3）聚集索引和非聚集索引

### 聚集索引和非聚集索引区别？
- 聚集索引： 
1）数据行的物理顺序（存储）与列值（一般是主键那一列，该列为聚集索引）的逻辑顺序相同，一个表只能拥有一个聚集索引 
2）查询效率高，只要找到第一个索引值记录，其余连续性的记录在物理上也一样连续性存放 
3）修改慢，为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序 
- 非聚集索引： 
1）索引的逻辑顺序与磁盘上存储的物理顺序不同。一个表可以拥有多个非聚集索引 
2）两种索引均为B+树结构，非聚集索引的叶子层并不和实际数据页重叠，而采用叶子层包含一个指向表中记录在数据页中的指针方式 
3）非聚集索引层次多，不会造成数据重排

### 辅助索引？
非主键的列生成的索引，InnoDB叶子节点存储主键ID，使用该索引作为过滤条件，会先在该索引树上找到对应的主键值，然后根据主键的值，到聚集索引（或者非聚集索引）中找到真实的表数据行

### 索引有哪些数据结构？
B树，B+树，hash表

### B树和B+树的区别？
1. B 树非叶子结点存储数据,因此查询数据时，时间复杂度最好为 O(1),最坏为 O(log n)。
2. B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。
3. B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历。

### B树和红黑树？
红黑树每个节点只有左右两个子节点，树的深度过大，造成磁盘IO读写过于频繁，进而效率低下，而B树可以有多个子女，减少树的高度，提高查询效率

### 文件索引和数据库索引为什么使用B+树而不是B树？
1）B+树的磁盘读写代价更低。B+树内部节点没有存储数据，因此其内部节点相对B树更小。将存放数据的指针的空间省下来，存放关键字，相同空间可以存放更多关键字，相对来说IO读写次数也就降低了
2）B+树的查询效率更加稳定。任何关键字的查找都需要走一条从根节点到叶子节点的查找路径，因此，所有关键字的查找路径相同，因此，查找每一个关键字的效率相当 
3）B+树，只要遍历叶子节点就可实现所有表记录的遍历，而B树只能中序遍历，效率较低，数据库中，基于范围的查询是非常频繁的，因此B+树更加适合。

### MySQL B+Tree索引和Hash索引的区别？
1）hash索引只能够满足“=”，“IN”等等值查询，不能使用范围查询。索引键经过哈希后，索引键的大小关系并不能保证，因而查询某一范围的键值对应的记录效率较低。而B+树，只需要遍历其叶子节点即可 
2）hash索引在键值的排序操作方面表现不是很好 
3）hash索引无法进行部分索引查询。对于组合索引，hash索引在计算hash值时，将索引键合并后，再计算哈希值，如果对索引中的部分列进行查询，无法利用哈希索引
4）hash索引遇到大量哈希值相等情况时，产生哈希碰撞，效率不高

### 什么是事务？
事务是一个不可分割的数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。执行的结果必须使得数据库从一个一致性状态变到另一种一致性状态

### 分布式事务？
https://blog.csdn.net/suchahaerkang/article/details/81407308

### 事务四大特性(ACID)？
1）原子性(A)：事务包含的所有操作，要么全部成功，要么全部失败回滚 
2）一致性(C)：事务总是从一个一致性状态转换到另外一个一致性状态。比如A向B转账后，系统崩溃，不可能A扣了钱，B却没收到 
3）隔离性(I)：多个用户并发访问数据库时，比如操作同一张表时，数据库为每个用户开启的事务，不能被其它事务的操作所干扰，多个并发的事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有干扰。一个事务所做的修改，在没有提交前对其他事务是不可见的。比如A正从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账 
4）持久性(D)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

### 保持数据库一致性的方法？
https://blog.csdn.net/lyfqyr/article/details/83351594 
1）尽可能使用约束，如外键，主键，非空字段等约束 
2）使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整性和一致性 
3）自写业务逻辑，这种方法相对麻烦，编程复杂，效率低下

### 事务的并发问题？
1）脏读：事务可以读取未提交的数据。即，事务中的修改，即使没有提交，对其他事务也都是可见的 
2）不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新，并提交，导致事务A多次读取同一数据时，结果不一致
3）幻读：当A事务读取某个范围内的记录后，B事务又在该范围内插入了新的记录，A事务再次读取该范围的记录时，发现和前一次读取到的数据不一样。 
备注：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于插入或删除，解决不可重复读，只需要锁住满足条件的行即可，解决幻读，则需要锁住相应表。

### 事务隔离级别？每个级别会引发什问题？MySQL默认是哪个级别？
1）未提交读：事务中的修改，即使没有提交，对其他事务也都是可见的。可能产生的问题有：脏读，不可重复读，幻读 
2）提交读：一个事务开始时，只能看见已经提交的事务所做的修改。可能产生的问题：不可重复读，幻读 
3）可重复读：在同一个事务中，多次读取同样的记录，结果是一致的。可能产生的问题：幻读 
4）可串行化：最高的隔离级别。强制事务串行执行，避免了脏读，不可重复读，幻读问题。可串行化在读取的每一行数据上都加锁，可能产生的问题：大量的超时和锁争用问题。

### 事务传播行为
1）PROPAGATION_REQUIRED：如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务，该设置是最常用的设置 
2）PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行 
3）PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常 
4）PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务 
5）PROPAGATION_NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则抛出异常 
6）PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常 
7）PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作

### 嵌套事务
嵌套是子事务在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫 save point，然后执行子事务，这个子事务的执行也是父事务的一部分。子事务结束后，父事务继续执行。

### 如果子事务回滚，会发生什么？
父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚

### 如果父事务回滚，会发生什么？
父事务回滚，子事务也跟着回滚。父事务结束之前，子事务是不会提交的。

### 子事务和父事务的提交顺序是什么？
子事务先提交，而后父事务再提交

### mysql都有什么锁？
1）表锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低 
2）行锁：开销大，加锁慢，会出现死锁。锁定粒度小，发生锁冲突的概率最低，并发度最高。 
3）页面锁：开锁和加锁时间介于表锁和行锁之间。会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

### 死锁判定原理和具体场景？
两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。

### 死锁怎么解决？
1）找出死锁进程，杀死进程（SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;） 
2）设置锁的超时时间。 
3）指定获取锁的顺序。

### 乐观锁和悲观锁（主要处理资源并发访问问题，实现并发控制）
1. 悲观锁 悲观锁的特点是先获取锁，再进行业务操作，即悲观地认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功，再进行业务操作。通常来讲，数据库上的悲观锁需要数据库本身提供支持，即通过常用的SELECT...FOR UPDATE操作来实现悲观锁。当数据库执行SELECT...FOR UPDATE时，会获取被SELECT中的数据行的行锁，因此其他并发执行的SELECT...FOR UPDATE试图获取相应行的行锁时，则发生排斥，需要等待行锁被释放，因此达到锁的效果。SELECT...FOR UPDATE获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 不同的数据库对SELECT...FOR UPDATE的实现和支持是有区别的，例如oracle支持SELECT...FOR UPDATE NO WAIT，表示如果拿不到锁，则立刻报错，而不是等待，MySQL则没有no wait这个选项。MySQL还有个问题，SELECT...FOR UPDATE 执行中，所有扫描过的行都会被锁上，这一点很容易产生问题。因此，如果MySQL中用悲观锁务必要确定使用了索引，而不是全表扫描。 
2. 乐观锁 乐观锁的特点是，先进行业务操作，只在最后实际更新数据时，进行检查数据是否被更新过，若未被更新过，则更新成功；若更新过，则失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持，一般的做法是在需要锁的数据上增加一个版本号或者时间戳。 其底层实现是这样的，在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时，再次获取版本号，对比两次获取的版本号，如果与之前获取的版本号相同，即可确认这期间没有发生并发的修改。如果更新失败，即认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，回滚整个业务操作，根据需要重试整个过程。

### 乐观锁和悲观锁的使用场景
一般情况下，读多写少的更适合用乐观锁，读少写多的更适合用悲观锁。乐观锁在不发生取锁失败时开销比悲观锁小，一旦发生失败，回滚开销则比较大。因此乐观锁适合用在取锁概率失败比较小的场景，提高系统并发性能。

### MVCC（多版本并发控制）简介
数据记录后会多出两列：事务 ID 和指向上个数据记录的指针(undo log 中)
选择当前事务可以看到的数据版本
在不加锁的情况下，实现提交读和可重复读

### MyISAM和InnoDB的区别？
MyISAM采用的是非聚集索引，查找慢，增删快；InnoDB采用的聚集索引，查找快，增删慢
1）MYISAM 使用的是非聚集索引，数据和索引存储在不同的地方，通过 MYISAM 的索引，能够找到相应数据记录的地址，然后再根据地址找到相应数据，需要两次查询；InnoDB 使用的是聚集索引，数据和索引存储在相同的地方，需要一次查询。
2）MYISAM 的辅助索引和主键索引具有相同的地位，InnoDB 需要利用辅助索引找到相应的主键索引，然后再利用主键索引找到相应的数据。
3）事务支持。MyISAM不支持事务，强调性能，每次查询具有原子性，执行速度比InnoDB快。InnoDB支持事务，具有事务提交，回滚和崩溃修复能力。 
4）表锁差异。MyISAM只支持表锁。用户在操作MyISAM表时，执行SELECT, UPDATE, DELETE, INSERT语句时，都会给表加锁。InnoDB支持行级锁。行锁大幅度提高了多用户并发操作的性能。InnoDB的行锁，只是在主键WHERE时有效，非主键WHERE时锁全表。 
4）MyISAM不支持外键，InnoDB支持外键。 
5）全文本索引。MyISAM支持FULLTEXT类型的全文本索引。InnoDB不支持FULLTEXT类型的全文本索引，但是InnoDB可以使用sphinx插件支持全文索引，并且效果更好。 
6）表的总行数。MyISAM保存表的总行数，SELECT Count(*) FROM table;会直接取出该值。而InnoDB没有保存表的总行数，使用SELECT Count(*) FROM table;时会遍历整个表，消耗较大。但是加了WHERE条件后，MyISAM和InnoDB的处理方式一样。 
7）AUTO_INCREMENT。在MyISAM中，自动增长列可以和其他列一起建立索引，自动增长列必须是索引。如果是组合索引，自动增长可以不是第一列。InnoDB中，必须有自动只有自动增长列的索引，并且自动增长列必须是索引。如果是组合索引，必须是组合索引的第一列。 
8）存储结构。每个MyISAM表在磁盘上存储成三个文件，第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，.myd存储数据，.myi存储索引。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件大小，一般为2GB 
9）存储空间。MyISAM可被压缩，占据的存储空间较小，支持静态表，动态表，压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池，用于高速缓冲数据和索引。 
10）可移植性、备份及恢复。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件，备份bin-log，或者用mysqldump，在数据量达到几十G的时候就相对痛苦了。 
11）CRUD：如果执行大量的SELECT，MyISAM是比较好的选择。如果数据需要执行大量的INSERT或UPDATE，出于性能考虑，应该使用InnoDB。DELETE，从性能说，InnoDB更优，但是，DELETE FROM table，InnoDB不会重新建表，而是一行一行删除，在InnoDB上，如果要清空保存有大量数据的表，最后使用truncate table


### nosql(not only SQL)分类？
https://www.cnblogs.com/mingzhang/p/9656129.html https://blog.csdn.net/alex_xfboy/article/details/82910080 
1）列存储。按列存储数据，方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。常见数据库有Hbase, Cassandra, Hypertable 
2）文档存储。文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。常见数据库有MongoDB, CouchDB 
3）key-value存储。可以通过key快速查询到value。一般来说，存储不管value的格式，照单全收。常见数据库有Redis，MemcacheDB，Berkeley DB，Tokyo Cabinet/Tyrant 
4）图存储。图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，设计使用不方便。常见数据库有Neo4J, FlockDB 
5）对象存储。通过类似面向对象语音的语法操作数据库，通过对象的方式存取数据。常见数据库有db4o, Versant 
6）xml数据库。高效的存储XMLA数据，并支持XML的内部查询语法。常见数据库有Berkeley DB XML, BaseX



