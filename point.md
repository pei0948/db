# 数据库相关的知识点

### 常见数据模型
> 1、层次模型：在层次模型中，记录被组织为**树**的形式。树中的每个节点，表示一个实体（相当于一个表）。
> - a.根节点没有父节点；
> - b.除根节点以外的其他节点，有且仅有一个父节点 
> 
> 2、网状模型：在网状模型中，记录被组织为**有向图**的形式。图中的每个节点，表示一个实体（相当于一个表），实体之间的关系在底层中可由指针实现。
> - a.允许一个以上的节点没有父节点;
> - b.一个节点可以拥有多个父节点 
> 
> 3、关系模型：在关系模型中，用表表示实体和实体间的联系 

https://blog.csdn.net/gengkui9897/article/details/89295649

### 非关系型数据库和关系型数据库区别，优势比较？
> 1）关系型数据库将记录和记录之间的关系存入**表**中，
> 优点：
> - a.易于维护，都是使用表结构，格式一致       
> - b.使用方便，SQL语言通用，可用于复杂查询       
> - c.支持复杂操作，支持SQL，可用于一个表及多个表之间非常复杂的查询 
> 
> 缺点：
> - a.读写性能比较差，尤其是海量数据的高效率读写
> - b.固定的表结构，稍微欠缺灵活性       
> - c.高并发读写需求，就传统关系型数据库来说，硬盘I/O是一个很大的瓶颈 
>
> 2）非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等，
> 优势：       
> - a.格式灵活，存储数据的格式可以是key-value形式，文档形式，图片形式等，使用灵活，应用场景广泛，而关系型数据库只支持基础类型       
> - b.速度快，nosql可以使用硬盘或者内存作为载体，而关系型数据库只能使用硬盘       
> - c.高扩展性       
> - d.成本低，nosql数据库部署简单，基本都是开源软件 
> 
> 缺点：       
> - a.不支持sql，学习和使用成本较高       
> - b.无事务处理       
> - c.数据结构相对复杂，稍微欠缺复杂查询

### 数据库连接是TCP还是UDP？
> - TCP
> - 默认端口号3306

### 数据库范式？
> 1.第一范式：列不可分，数据库中的所有字段都是不可分解的原子值（例如，地址可分为，国家，城市，县区等，可分割，不满足第一范式） 
> 2.第二范式：在第一范式基础上，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键）。也就是说，在一个数据库表中，一个表只能保存一种数据，不可以把多种数据保存在同一张表中 
> 3.第三范式：无传递性依赖。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能是间接相关。（例如，学生表，有学院，学院地址，学院电话等，学院与主键相关，但是学院地址和学院电话等只与学院相关，与主键无关，因此不满足第三范式）

https://zhuanlan.zhihu.com/p/128546246

### 数据库三级模式？
> 1.面向用户或应用程序员的用户级，对应于外模式 
> 2.面向建立和维护数据库人员的概念级，对应模式（又叫概念模式，逻辑模式） 
> 3.面向系统程序员的物理级，对应内模式 

https://blog.csdn.net/qq_42175113/article/details/82831884

### 什么是临时表？临时表什么时候删除？
> 临时表只在当前连接可见，当关闭连接时，Mysql会自动删除临时表，并释放空间。因此，在不同的连接中，可以创建同名的临时表，并且操作属于本连接的临时表 
> 删除： 
> - 1）关闭连接时，Mysql会自动删除临时表，并释放空间 
> - 2）手动删除（DROP TEMPORARY TABLE IF EXISTS tmp_tb）; 创建临时表与创建普通表类似，只是多了TEMPORARY关键字： CREATE TEMPORARY TABLE tmp_tb(...); 

https://www.cnblogs.com/wenxiaofei/p/9853682.html

### 数据库的主从复制方式？
> 1）同步复制：master(主数据库)的变化，必须等待slave-1(从数据库-1)，slave-2,...,slave-n完成后才能返回。这样不可取，也不是Mysql复制的默认设置，比如（在WEB前端页面上，用户增加了一条数据，需要等待很长时间） 
> 2）异步复制：master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志（bin-log文件，存储主库执行过的sql语句的二进制），是否完成操作，不用关心。该项为Mysql的默认设置 
> 3）半同步复制：master只保证slaves中的一个操作成功，就返回，其他slaves不管。该功能为google引入mysql的

### 数据库主从复制的7个问题？
> 1）是否可以向slave进行写操作？
> - 不可以。如果slaves可以进行写操作，slave又无法通知到master，这样使得master和slave数据不一致。 
>
> 2）slave能够带来哪些好处？
> - a.数据备份。一旦master出现问题，可以让slave顶上去，提升slave为master       
> - b.负载均衡。通过服务器复制功能，可以在主服务器与从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询，从而得到更好地客户响应时间 
> 
> 3）主从复制中，有多个slave，JAVA WEB应用应该选择哪个数据库？       
> - 应用程序承担SQL语句的路由。insert/delete/update这些更新操作，用connection(for master)进行，select用connection(for slaves)进行操作。这样可能会出现这样的问题：如果master坏掉了，或者一些slave坏掉了，那么就需要更改应用程序。       
> - 2）利用相应组件承担SQL语句的路由。由一些组件（比如haproxy）承担SQL语句的路由 
>
> 4）如果mysql proxy,direct,master中的一些坏掉了，怎么办？       
> - 可以给某些关键节点做备份 
> 
> 5）存在N个slave，master在发送二进制日志时，是否一定需要发送N次？       
> - 不一定。如果发送N次，master内部需要维护N个线程，每个线程负责将二进制日志文件发往对应的slave，master既要负责写操作，还需要维护N个线程负担太重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主服务器，slave-1将master的复制线程的负担转移到自己身上，这就是所谓的多级复制的概念。 
> 
> 6）当一个select发往Mysql proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了？
> - 应该找一个共享式的缓存，比如memcache解决，将slave-2,slave-3，。。。这些查询的结果都缓存至memcache中 
> 
> 7）随着应用的日益增多，读操作很多，可以扩展slave，但是如果master满足不了写操作了，该怎么办？      
> - a）将master换做更好的服务器      
> - b）可以分库（垂直拆分），分表（水平拆分）

### 数据库分片、分区、分表、分库
> 切分的目的：减少数据库负担，缩短查询时间 数据切分有两种类型：
> - 垂直切分
> - 水平切分

> 垂直切分
> 1 垂直分库
> - 垂直分库：根据业务耦合性，将关联度低的不同表存储在不同的数据库。  
> 
> 2 垂直分表 
> - 垂直分表：基于数据库中的列进行。某个表字段较多，可以新建一张扩展表，将不经常用或字段较大的字段拆分出去到扩展表中。

当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈时，这时候就需要进行水平切分了
> 水平切分
> 1 库内分表
> - 根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小。
> 
> 2 分库分表
> - 将库内分表分得的表存储在不同的数据库上

### Mysql高并发环境解决方案？
> 分库，分表，分布式，增加二级缓存 
> 
> 需求分析：互联网单位，每天大量数据读取，写入，并发性高 
> - 现有解决方案：水平分库、分表，由单点分布到多点数据库中，从而降低单点数据库压力 
> - 集群方案：解决数据库宕机带来的单点数据库不能访问的问题
> 
> 读写分离策略：极大限度提高了应用中read数据的速度和并发量，无法解决高写入压力

### 数据库崩溃时事务的恢复机制？ （REDO日志和UNDO日志）
> 1）Undo log：Undo log是为了实现事务的原子性。在Mysql数据库InnoDB存储引擎中，还用了Undo log来实现多版本并发控制（MVCC）      
> - 原理：为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo log），然后进行数据修改，如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到开始之前的状态。 
> 
> 2）Redo log:      
> - 原理：和Undo log相反，Redo Log记录的是新数据的备份，在事务提交前，只要将Redo log持久化即可，不需要将数据持久化，当系统崩溃时，虽然数据没有持久化，但是Redo log已经持久化，系统可以根据Redo log的内容，将所有数据恢复到最新的状态